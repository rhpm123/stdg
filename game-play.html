<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>틀린그림찾기 게임</title>
  
  <!-- 캐시 무력화 스크립트 (개발용) -->
  <script src="assets/js/cache-buster.js"></script>
  
  <!-- JavaScript 강제 실행 스크립트 (개발용) -->
  <script src="assets/js/force-js-execution.js"></script>
  
  <!-- 응급 CSS 주입 스크립트 (개발용) -->
  <script src="assets/js/emergency-css-injection.js"></script>
  
  <!-- CSS 모듈 -->
  <!-- CSS 기본 모듈들 -->
  <link rel="stylesheet" href="assets/css/game/variables.css">
  <link rel="stylesheet" href="assets/css/game/base.css">
  <link rel="stylesheet" href="assets/css/game/layout.css">
  <link rel="stylesheet" href="assets/css/game/components.css">
  <link rel="stylesheet" href="assets/css/game/health-bar.css">
  <link rel="stylesheet" href="assets/css/game/animations.css">
  <link rel="stylesheet" href="assets/css/game/responsive.css">
  
  <!-- 회전 안내 UI 오버레이 -->
  <link rel="stylesheet" href="assets/css/game/orientation.css">
  
  <!-- 메인 게임 스타일 -->
  <link rel="stylesheet" href="assets/css/game-play.css">
  </head>
  <body>
  <!-- 회전 안내 오버레이 -->
  <div class="orientation-overlay">
    <div class="orientation-game-name">틀린그림찾기</div>
    <div class="rotate-icon-container">
      <div class="phone-icon"></div>
      <div class="rotate-arrow">↻</div>
    </div>
    <div class="orientation-text">
      <div class="orientation-title">📱 핸드폰을 회전하세요</div>
      <div class="orientation-subtitle">더 나은 게임 경험을 위해<br>가로모드로 플레이해주세요</div>
    </div>
  </div>

  <!-- 상단 헤더: 게임 제목 + 사용자 정보 -->
    <header class="game-header-top">
      <div class="game-header">
        <h1 class="game-title">틀린그림찾기 게임</h1>
      </div>
      
      <!-- 사용자 정보 영역 -->
      <div class="user-section" id="userSection">
        <!-- 인증 관리자가 동적으로 채움 -->
      </div>
    </header>
    
    <!-- 메인 레이아웃 래퍼 (그리드: 콘텐츠 + 사이드바) -->
    <div class="main-layout-wrapper">
      <!-- 메인 콘텐츠 영역 -->
      <div class="main-layout-content">
    <!-- 메인 이미지 영역 -->
    <main class="main-content">
      <div class="images-container" id="imagesContainer" style="display: none;">
        <div class="image-section">
          <h3>원본 이미지</h3>
          <div class="image-container" id="originalContainer">
            <img id="originalImage" class="game-image" src="" alt="원본 이미지">
          </div>
        </div>
        
        <div class="image-section">
          <h3>수정 이미지 (여기서 찾으세요!)</h3>
          <div class="image-container" id="modifiedContainer">
            <img id="modifiedImage" class="game-image" src="" alt="수정 이미지">
          </div>
        </div>
      </div>
    </main>
      </div> <!-- main-layout-content 종료 -->
      
      <!-- 오른쪽 사이드바 (데스크톱 전용, 바텀바와 동일한 구조) -->
      <div class="right-sidebar">
        <!-- 사이드바 게임 통계 섹션 -->
        <div class="sidebar-section sidebar-stats">
          <h4>게임 정보</h4>
          <div class="sidebar-stats-grid">
            <div class="sidebar-stat-item">
              <span class="sidebar-stat-label">점수</span>
              <span class="sidebar-stat-value" id="sidebarScore">0</span>
            </div>
            <div class="sidebar-stat-item">
              <span class="sidebar-stat-label">시간</span>
              <span class="sidebar-stat-value" id="sidebarTimer">00:00</span>
            </div>
            <div class="sidebar-stat-item">
              <span class="sidebar-stat-label">진행</span>
              <span class="sidebar-stat-value" id="sidebarFound">0/0</span>
            </div>
            <div class="sidebar-stat-item">
              <span class="sidebar-stat-label">생명</span>
              <span class="sidebar-stat-value" id="sidebarLives">❤️❤️❤️❤️❤️</span>
            </div>
          </div>
        </div>
        
        <!-- 사이드바 진행바 섹션 -->
        <div class="sidebar-section sidebar-progress">
          <h4>체력</h4>
          <!-- 체력바 (시간 제한 시각화) -->
          <div class="sidebar-health-bar-section" id="sidebarHealthBarSection">
            <div class="health-bar">
              <div class="health-bar-fill" id="sidebarHealthBarFill"></div>
              <div class="health-bar-text" id="sidebarHealthBarText">100%</div>
            </div>
          </div>
        </div>
        
        <!-- 사이드바 컨트롤 섹션 -->
        <div class="sidebar-section sidebar-controls">
          <h4>게임 제어</h4>
          <div class="sidebar-controls-grid">
            <button class="sidebar-btn btn-primary" id="sidebarStartBtn">게임 시작</button>
            <button class="sidebar-btn hint-btn" id="sidebarHintBtn" disabled>💡 힌트</button>
          </div>
        </div>
      </div> <!-- right-sidebar 종료 -->
    </div> <!-- main-layout-wrapper 종료 -->
  
    <!-- 바텀바 제거됨: 사이드바 시스템으로 완전 전환 -->
          
            <!-- JavaScript 모듈들 -->
  <!-- Supabase 클라이언트 -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  
  <!-- 모듈 로딩 시스템 (의존성 관리) -->
  <script src="assets/js/module-loader.js"></script>
  
  <!-- 게임 스크립트들 -->
  <script src="assets/js/game-state.js"></script>
  <script src="assets/js/orientation-controller.js"></script>
  <script src="assets/js/layout-manager.js"></script>
  <script src="assets/js/heart-system.js"></script>
  <script src="assets/js/health-bar-system.js"></script>
  <script src="assets/js/coordinate-utils.js"></script>
  <script src="assets/js/api-client.js"></script>
  <script src="assets/js/game-logic.js"></script>
  <script src="assets/js/click-handler.js"></script>
  <script src="assets/js/answer-display.js"></script>
  
  <!-- 메인 게임 초기화 -->
  <script>
    console.log('🎮 게임 시작!');
    
    // 인증 상태 캐시 변수
    let authStateCache = null;
    let lastAuthCheck = 0;
    const AUTH_CACHE_DURATION = 30000; // 30초 캐시
    
    // 인증 상태 캐시 클리어
    function clearAuthCache() {
      authStateCache = null;
      lastAuthCheck = 0;
      console.log('인증 상태 캐시가 클리어되었습니다.');
    }
    // 메시지 표시 함수
    // 메시지 표시 함수
    function showMessage(message, type = 'error') {
      const errorEl = document.getElementById('errorMessage');
      const successEl = document.getElementById('successMessage');
      
      // DOM 요소가 없으면 콘솔로 메시지 출력
      if (!errorEl || !successEl) {
        console.log(`📱 [${type.toUpperCase()}] ${message}`);
        return;
      }
      
      errorEl.style.display = 'none';
      successEl.style.display = 'none';
      
      if (type === 'error') {
        errorEl.textContent = message;
        errorEl.style.display = 'block';
      } else {
        successEl.textContent = message;
        successEl.style.display = 'block';
      }
      
      setTimeout(() => {
        if (errorEl) errorEl.style.display = 'none';
        if (successEl) successEl.style.display = 'none';
      }, 3000);
    }
    
    // 인증 상태 확인 함수 (간단한 대체 구현)
    async function checkAuthState() {
      try {
        // 캐시된 결과가 있고 30초 이내면 사용
        const now = Date.now();
        if (authStateCache && (now - lastAuthCheck) < AUTH_CACHE_DURATION) {
          console.log('📄 캐시된 인증 상태 반환:', authStateCache);
          return authStateCache;
        }
        
        // 로컬 스토리지에서 토큰 확인
        const token = localStorage.getItem('supabaseToken');
        const user = localStorage.getItem('supabaseUser');
        const expiry = localStorage.getItem('supabaseTokenExpiry');
        
        if (!token || !user) {
          console.log('❌ 토큰 또는 사용자 정보 없음');
          authStateCache = { isAuthenticated: false, user: null };
          lastAuthCheck = now;
          return authStateCache;
        }
        
        // 토큰 만료 확인
        if (expiry && parseInt(expiry) < now) {
          console.log('⏰ 토큰 만료됨');
          localStorage.removeItem('supabaseToken');
          localStorage.removeItem('supabaseUser');
          localStorage.removeItem('supabaseTokenExpiry');
          authStateCache = { isAuthenticated: false, user: null };
          lastAuthCheck = now;
          return authStateCache;
        }
        
        // 사용자 정보 파싱
        let userObj;
        try {
          userObj = JSON.parse(user);
        } catch (parseError) {
          console.error('사용자 정보 파싱 오류:', parseError);
          authStateCache = { isAuthenticated: false, user: null };
          lastAuthCheck = now;
          return authStateCache;
        }
        
        console.log('✅ 인증된 사용자:', { id: userObj.id, email: userObj.email });
        authStateCache = { isAuthenticated: true, user: userObj };
        lastAuthCheck = now;
        return authStateCache;
        
      } catch (error) {
        console.error('❌ 인증 상태 확인 오류:', error);
        authStateCache = { isAuthenticated: false, user: null };
        lastAuthCheck = Date.now();
        return authStateCache;
      }
    }
    function showLoading(show = true) {
      const loadingEl = document.getElementById('loading');
      
      // DOM 요소가 없으면 콘솔로 메시지 출력
      if (!loadingEl) {
        console.log(`🔄 [LOADING] ${show ? '로딩 시작' : '로딩 종료'}`);
        return;
      }
      
      if (show) {
        loadingEl.style.display = 'block';
        setTimeout(() => {
          if (loadingEl) loadingEl.style.display = 'none';
        }, 10000);
      } else {
        loadingEl.style.display = 'none';
      }
    }
    
    // 힌트 기능
    let hintCount = 0;
    const maxHints = 5;
    
    function showHint() {
      if (!gameState.isGameActive || gameState.isPaused) {
        showMessage('게임이 진행 중일 때만 힌트를 사용할 수 있습니다.', 'error');
        return;
      }
      
      if (hintCount >= maxHints) {
        showMessage('힌트를 모두 사용했습니다.', 'error');
        return;
      }
      
      if (!gameState.answerPoints || gameState.answerPoints.length === 0) {
        showMessage('게임 데이터가 로딩되지 않았습니다.', 'error');
        return;
      }
      
      // 아직 찾지 못한 영역들 중에서 랜덤하게 하나 선택
      const unfoundRegions = gameState.answerPoints
        .map((_, index) => index)
        .filter(index => !gameState.foundPoints.includes(index));
      
      if (unfoundRegions.length === 0) {
        showMessage('모든 정답을 찾았습니다!', 'success');
        return;
      }
      
      // 랜덤하게 하나의 영역 선택
      const randomIndex = Math.floor(Math.random() * unfoundRegions.length);
      const hintRegionIndex = unfoundRegions[randomIndex];
      
      // 힌트 사용 횟수 증가
      hintCount++;
      
      // 선택된 영역을 3초간 깜빡이게 함
      showDifferenceBlinking(hintRegionIndex, 3000);
      
      // 힌트 버튼 텍스트 업데이트
      updateHintButton();
      
      showMessage(`힌트! 깜빡이는 영역을 확인하세요 (${hintCount}/${maxHints})`, 'success');
      
      console.log('💡 힌트 사용:', {
        사용횟수: `${hintCount}/${maxHints}`,
        힌트영역: hintRegionIndex,
        남은미발견영역: unfoundRegions.length - 1
      });
    }
    
    function updateHintButton() {
      const hintBtn = document.getElementById('hintBtn');
      if (hintBtn) {
        const remaining = maxHints - hintCount;
        hintBtn.textContent = `💡 힌트 (${remaining}/${maxHints})`;
        
        if (remaining === 0) {
          hintBtn.disabled = true;
          hintBtn.style.opacity = '0.5';
        } else {
          hintBtn.disabled = false;
          hintBtn.style.opacity = '1';
        }
      }
    }
    
    // 게임 시작 시 힌트 초기화
    function resetHintSystem() {
      hintCount = 0;
      updateHintButton();
      console.log('🔄 힌트 시스템 초기화');
    
    }

    // 이벤트 리스너 설정
    function setupEventListeners() {
      console.log('🔧 [DEBUG] setupEventListeners 호출됨!');
      
      // 게임 제어 버튼들
      const startBtn = document.getElementById('startBtn');
      const resetBtn = document.getElementById('resetBtn');
      
      console.log('🎯 [DEBUG] 버튼 요소 확인:', {
        startBtn: startBtn,
        resetBtn: resetBtn,
        startBtnId: startBtn?.id,
        resetBtnId: resetBtn?.id
      });
      
      // 버튼 위치 정보 확인
      if (startBtn && resetBtn) {
        const startRect = startBtn.getBoundingClientRect();
        const resetRect = resetBtn.getBoundingClientRect();
        
        console.log('📐 [DEBUG] 버튼 위치 정보:', {
          startBtn: {
            x: startRect.x,
            y: startRect.y,
            width: startRect.width,
            height: startRect.height,
            right: startRect.right,
            bottom: startRect.bottom
          },
          resetBtn: {
            x: resetRect.x,
            y: resetRect.y,
            width: resetRect.width,
            height: resetRect.height,
            right: resetRect.right,
            bottom: resetRect.bottom
          }
        });
        
        // 겹침 여부 확인
        const isOverlapping = !(
          startRect.right < resetRect.left || 
          resetRect.right < startRect.left || 
          startRect.bottom < resetRect.top || 
          resetRect.bottom < startRect.top
        );
        
        console.log(`${isOverlapping ? '❌ [WARNING]' : '✅ [OK]'} 버튼 겹침 여부: ${isOverlapping}`);
      }
      if (startBtn) {
        console.log('🚀 [DEBUG] startBtn에 startGame 이벤트 리스너 등록');
        startBtn.addEventListener('click', function(event) {
          console.log('🔴 [DEBUG] START 버튼 클릭 이벤트 발생!', event.target);
          startGame();
        });
      }
      
      if (resetBtn) {
        console.log('🔄 [DEBUG] resetBtn에 resetGame 이벤트 리스너 등록');
        resetBtn.addEventListener('click', function(event) {
          console.log('🔵 [DEBUG] RESET 버튼 클릭 이벤트 발생!', event.target);
          resetGame();
        });
      }
      

      document.getElementById('hintBtn')?.addEventListener('click', showHint);
      document.getElementById('newGameBtn')?.addEventListener('click', () => {
        window.location.href = '../index.html';
      });
      document.getElementById('toggleAnswerBtn')?.addEventListener('click', toggleAnswerPoints);
      
      // 디버그 모드 토글
      document.getElementById('debugModeBtn')?.addEventListener('click', () => {
        debugMode = !debugMode;
        const btn = document.getElementById('debugModeBtn');
        const devTools = document.getElementById('devTools');
        
        // 버튼 텍스트와 색상 동시 업데이트
        btn.textContent = debugMode ? '🔧 디버그 OFF' : '🔧 디버그 모드';
        btn.style.backgroundColor = debugMode ? '#e74c3c' : '#f39c12';
        
        // 개발자 도구 패널 토글
        devTools.style.display = debugMode ? 'block' : 'none';
        
        showMessage(`디버그 모드 ${debugMode ? 'ON' : 'OFF'}`, 'success');
        });
        
      
      // 이미지 클릭 이벤트
      const modifiedImg = document.getElementById('modifiedImage');
      if (modifiedImg) {
        modifiedImg.addEventListener('click', (event) => {
          if (debugMode) {
            debugClickHandler(event);
          } else {
            handleImageClick(event);
          }
        });
      }
      
      console.log('✅ 이벤트 리스너 설정 완료');
    }
    
    window.addEventListener('load', async function() {
      console.log('📱 페이지 로드 완료, 표준화된 초기화 시작!');
      
      try {
        // === 1단계: 표준화된 초기화 (링크 소스 무관) ===
        
        // 이벤트 리스너 설정
        setupEventListeners();
        
        // 인증 상태 캐시 강제 클리어 (일관성 보장)
        clearAuthCache();
        console.log('🔄 인증 상태 캐시 강제 클리어 완료');
        
        // 게임 상태 초기화 (모든 접속에서 동일한 시작점)
        resetGameState();
        console.log('🎮 게임 상태 표준화 초기화 완료');
        
        // === 2단계: 환경 설정 로드 ===
        
        // 환경변수를 API에서 가져오는 함수
        async function loadSupabaseConfig() {
          try {
            const response = await fetch('/api/config');
            const config = await response.json();
            return {
              url: config.supabaseUrl,
              anonKey: config.anon_key
            };
          } catch (error) {
            console.error('설정 로드 오류:', error);
            // 폴백: 하드코딩된 값 사용
            return {
              url: 'https://ysvxjmqdafldfrmdscvd.supabase.co',
              anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlzdnhqbXFkYWZsZGZybWRzY3ZkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIxODU5ODMsImV4cCI6MjA1Nzc2MTk4M30.lKRd0cPCFLMJFWT1lMrp7DOAjlx85Q-pbnsXTiE22G4'
            };
          }
        }
        
        // === 3단계: OAuth 토큰 처리 (모든 링크에서 동일한 방식) ===
        
        // URL fragment 정리 (토큰 여부와 관계없이 항상 실행)
        const urlParams = new URLSearchParams(window.location.hash.substring(1));
        const accessToken = urlParams.get('access_token');
        const refreshToken = urlParams.get('refresh_token');
        const expiresAt = urlParams.get('expires_at');
        
        // URL 정리 (토큰 제거) - 모든 경우에 실행
        if (window.location.hash) {
          window.history.replaceState({}, document.title, window.location.pathname + window.location.search);
          console.log('🧹 URL fragment 정리 완료');
        }
        
        // OAuth 토큰이 있는 경우에만 처리
        if (accessToken && refreshToken) {
          console.log('🔑 OAuth 토큰 발견, 세션 설정 중...');
          try {
            // Supabase 설정을 API에서 가져오기
            const config = await loadSupabaseConfig();
            
            // Supabase 클라이언트 가져오기 (이미 생성된 클라이언트 또는 새로 생성)
            let supabaseClient = window.supabaseClient;
            if (!supabaseClient && window.supabase) {
              supabaseClient = window.supabase.createClient(config.url, config.anonKey);
              window.supabaseClient = supabaseClient;
            }
            
            const sessionData = {
              access_token: accessToken,
              refresh_token: refreshToken,
              expires_at: expiresAt ? parseInt(expiresAt) : Math.floor(Date.now() / 1000) + 3600,
              token_type: 'bearer',
              user: null // Supabase가 자동으로 설정함
            };
            
            const { data, error } = await supabaseClient.auth.setSession(sessionData);
            
            if (error) {
              console.error('❌ 세션 설정 실패:', error);
            } else {
              console.log('✅ 세션 설정 성공:', data);
              
              // 로컬 스토리지에도 토큰 저장
              localStorage.setItem('supabaseToken', accessToken);
              localStorage.setItem('supabaseTokenExpiry', String(sessionData.expires_at * 1000));
              
              if (data.user) {
                localStorage.setItem('supabaseUser', JSON.stringify(data.user));
              }
            }
          } catch (tokenError) {
            console.warn('⚠️ 토큰 처리 중 오류:', tokenError);
          }
          
          // 토큰 처리 후 안정화 대기
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // === 4단계: 인증 상태 확인 및 UI 업데이트 (표준화) ===
        
        // 인증 상태 재확인 (캐시 무효화 후)
        clearAuthCache();
        
        try {
          const authState = await checkAuthState();
          console.log('🔐 최종 인증 상태:', authState);
          
          // 로그인된 사용자의 경우에만 하트 시스템 초기화
          if (authState.isAuthenticated && authState.user) {
            try {
              const heartInitSuccess = await window.heartSystem.init(authState.user.id);
              if (heartInitSuccess) {
                console.log('💖 하트 시스템 초기화 성공');
              } else {
                console.warn('⚠️ 하트 시스템 초기화 실패, 게스트 모드로 진행');
              }
            } catch (heartError) {
              console.warn('⚠️ 하트 시스템 초기화 중 오류:', heartError.message);
              console.log('게스트 모드로 진행합니다.');
            }
          } else {
            console.log('👤 게스트 모드로 진행합니다.');
          }
          
          await updateUserInterface();
        } catch (authError) {
          console.warn('⚠️ 인증 확인 실패:', authError.message);
          console.log('게스트 모드로 진행합니다.');
          await updateUserInterface();
        }
        
        // === 5단계: 게임 시스템 초기화 ===
        
        // 시간 제한 시각화 시스템 초기화
        console.log('🔍 healthBarSystem 존재 여부:', typeof window.healthBarSystem);
        if (typeof window.healthBarSystem !== 'undefined') {
          console.log('🔍 healthBarSection DOM 요소 상태:', {
            요소존재: !!document.getElementById('healthBarSection'),
            클래스: document.getElementById('healthBarSection')?.className,
            표시상태: document.getElementById('healthBarSection') ? window.getComputedStyle(document.getElementById('healthBarSection')).display : 'N/A'
          });
          
          const healthBarInitSuccess = window.healthBarSystem.init();
          if (healthBarInitSuccess) {
            console.log('⏱️ 시간 제한 시각화 시스템 초기화 성공');
          } else {
            console.warn('⚠️ 시간 제한 시각화 시스템 초기화 실패');
          }
        } else {
          console.error('❌ healthBarSystem이 로드되지 않았습니다!');
        }
        
        // 게임 데이터 로딩 (표준화된 순서)
        await loadGameData();
        
        // 체력바 시스템 시작 (게임 데이터 로딩 후)
        if (typeof window.healthBarSystem !== 'undefined') {
          console.log('🚀 체력바 시스템 수동 시작...');
          window.healthBarSystem.start();
          console.log('✅ 체력바 시스템 수동 시작 완료');
        }
        
        // UI 업데이트 (모든 초기화 완료 후)
        updateUI();
        
        // Orientation Controller 초기화 및 이벤트 리스너 설정
        if (typeof window.orientationController !== 'undefined') {
          console.log('🔄 Orientation Controller 초기화...');
          
          // OrientationController 초기화
          window.orientationController.initOrientation();
          
          // Orientation 변경 시 게임 버튼 상태 업데이트
          window.orientationController.addCallback('orientationChange', (data) => {
            console.log('📱 Orientation 변경 감지:', data);
            updateGameButtonStates();
          });
          
          // 초기 게임 버튼 상태 설정
          updateGameButtonStates();
          
          console.log('✅ Orientation Controller 초기화 완료');
        } else {
          console.warn('⚠️ OrientationController를 찾을 수 없음');
        }
        
        // === 최종 완료 메시지 ===
        showMessage('게임 준비 완료! 시작 버튼을 눌러주세요.', 'success');
        console.log('🎉 표준화된 초기화 완료 - 모든 링크 소스에서 동일한 상태');
        
      } catch (error) {
        console.error('❌ 게임 초기화 실패:', error);
        showMessage(`게임 초기화 실패: ${error.message}`, 'error');
      }
    });
    
    /**
     * 사용자 인터페이스 업데이트
     */
    async function updateUserInterface() {
      const userSection = document.getElementById('userSection');
      const bestScoreSection = document.getElementById('bestScoreSection');
      const bestScoreEl = document.getElementById('bestScore');
      
      try {
                const authState = await checkAuthState();
        
        if (userSection) {
          if (authState.isAuthenticated && authState.user) {
            // 로그인 상태 UI
            userSection.innerHTML = `
              <div class="user-info">
                <div class="user-avatar">
                  <img src="${authState.user.user_metadata?.avatar_url || 'https://via.placeholder.com/40x40/4CAF50/FFFFFF?text=U'}" 
                       alt="프로필" style="width: 40px; height: 40px; border-radius: 50%;">
                </div>
                <div class="user-details">
                  <div class="user-name">👋 ${authState.user.user_metadata?.full_name || authState.user.email}</div>
                  <div class="user-email">${authState.user.email}</div>
                </div>
                <button onclick="logout()" class="control-btn btn-secondary" style="margin-top: 10px;">로그아웃</button>
              </div>
            `;
          } else {
            // 게스트 상태 UI
            userSection.innerHTML = `
              <div class="guest-info">
                <div class="guest-message">
                  <span>🎮 게스트 모드</span>
                  <div style="font-size: 12px; color: #888; margin: 5px 0;">
                    로그인하면 더 많은 기능을 이용할 수 있습니다!
                  </div>
                </div>
                <button onclick="loginWithGoogle()" class="control-btn btn-primary" style="margin-top: 10px;">
                  <span>🔑 구글 로그인</span>
                </button>
              </div>
            `;
          }
        }
        
        // 로그인된 사용자의 최고 점수 표시
        if (authState.isAuthenticated && bestScoreSection && bestScoreEl) {
          try {
            // 최고 점수 기능은 향후 구현 예정
            if (bestScoreSection) {
              bestScoreSection.style.display = 'none';
            }
          } catch (error) {
            console.log('최고 점수 API가 구현되지 않음:', error.message);
            if (bestScoreSection) {
              bestScoreSection.style.display = 'none';
            }
          }
        }
      } catch (error) {
        console.error('사용자 인터페이스 업데이트 실패:', error);
      }
    }
    
    // 게임 시작 전 정답 영역 숨김
    window.addEventListener('beforeunload', () => {
      hideAnswerPoints();
    });

    /**
     * 개발자용 힌트 리셋 함수
     */
    async function resetDeveloperHints() {
      try {
                const authState = await checkAuthState();
        
        // 로그인된 사용자인지 확인 (개발자 권한은 향후 구현)
        if (authState.isAuthenticated) {
          // 힌트 데이터 리셋 로직 (향후 구현 예정)
          showMessage('🛠️ 힌트 리셋 기능은 향후 구현 예정입니다.', 'success');
        } else {
          showMessage('이 기능을 사용하려면 로그인이 필요합니다.', 'error');
        }
      } catch (error) {
        console.error('개발자 힌트 리셋 오류:', error);
        showMessage('기능 실행 중 오류가 발생했습니다.', 'error');
      }
    }

    // 전역 함수로 노출
    window.showLoading = showLoading;
    window.showMessage = showMessage;
    window.resetDeveloperHints = resetDeveloperHints;
    
    // authModule을 전역 authManager로 노출 (대체 구현)
    // window.authManager = authModule;
    
    // 인증 관련 전역 함수
    window.loginWithGoogle = async () => {
      try {
        // 간단한 구글 로그인 대체 구현
        console.log('구글 로그인 요청');
        // 로그인 페이지로 리다이렉트
        window.location.href = '/login.html';
      } catch (error) {
        console.error('구글 로그인 중 오류:', error);
        showMessage('로그인 중 오류가 발생했습니다.', 'error');
      }
    };
    window.logout = async () => {
      try {
        // 인증 캐시 먼저 클리어
        clearAuthCache();
        
        // 간단한 로그아웃 대체 구현
        console.log('로그아웃 처리');
        localStorage.removeItem('supabaseToken');
        localStorage.removeItem('supabaseUser');
        localStorage.removeItem('supabaseTokenExpiry');
        
        showMessage('로그아웃 되었습니다. 로그인 페이지로 이동합니다.', 'success');
        // 2초 후 로그인 페이지로 리다이렉트
        setTimeout(() => {
          window.location.href = '/login.html';
        }, 2000);
      } catch (error) {
        console.error('로그아웃 중 오류:', error);
        showMessage('로그아웃 중 오류가 발생했습니다.', 'error');
      }
    };
    </script>
    
    
    </body>
    </html>