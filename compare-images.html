<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ì´ë¯¸ì§€ ë¹„êµ - í‹€ë¦°ê·¸ë¦¼ì°¾ê¸°</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 30px;
    }
    .images-container {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      flex-wrap: wrap;
    }
    .image-wrapper {
      flex: 1;
      min-width: 45%;
      position: relative;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }
    .image-wrapper h2 {
      text-align: center;
      background-color: #4a6baf;
      color: white;
      padding: 10px;
      margin: 0;
    }
    .image-container {
      position: relative;
      width: 100%;
      overflow: visible;
      text-align: center;
    }
    .image-container img {
      display: block;
      max-width: 100%;
      margin: 0 auto;
      cursor: crosshair;
    }
    .point {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: rgba(255, 0, 0, 0.3);
      border: 2px solid rgba(255, 0, 0, 0.8);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      transition: width 0.3s, height 0.3s;
    }
    .controls {
      margin-top: 20px;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .data-display {
      margin-top: 20px;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .data-display h3 {
      margin-top: 0;
    }
    button {
      background-color: #4a6baf;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 10px;
      font-weight: bold;
    }
    button:hover {
      background-color: #3a539b;
    }
    textarea {
      width: 100%;
      height: 150px;
      margin-top: 10px;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
      font-family: monospace;
    }
    .threshold-controls {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    .threshold-controls label {
      margin-right: 10px;
      font-weight: bold;
    }
    .threshold-controls input {
      margin-right: 20px;
    }
    #analysis-canvas {
      display: none;
    }
    .result-canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    .display-mode {
      margin-top: 10px;
      margin-bottom: 15px;
    }
    .display-mode label {
      margin-right: 15px;
      font-weight: bold;
    }
    .legend {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-right: 20px;
      margin-bottom: 5px;
    }
    .legend-color {
      width: 15px;
      height: 15px;
      margin-right: 5px;
      border-radius: 3px;
    }
    .pre-merge {
      background-color: rgba(255, 165, 0, 0.7);
    }
    .post-merge {
      background-color: rgba(255, 0, 0, 0.7);
    }
    .correct-answer {
      background-color: rgba(0, 255, 0, 0.5);
    }
    .game-mode {
      background-color: #4a6baf;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      color: white;
    }
    .game-mode h3 {
      margin-top: 0;
      margin-bottom: 15px;
    }
    .progress-bar {
      height: 20px;
      background-color: #ddd;
      border-radius: 10px;
      margin-top: 10px;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background-color: #27ae60;
      width: 0%;
      transition: width 0.3s ease;
    }
    .status {
      margin-top: 10px;
      font-style: italic;
      color: #666;
    }
    .auto-detect {
      background-color: #27ae60;
    }
    .auto-detect:hover {
      background-color: #219653;
    }
    .file-inputs {
      margin-bottom: 20px;
    }
    .file-inputs input {
      margin-bottom: 10px;
    }
    .file-inputs label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .answer-mode-options {
      margin-top: 10px;
      margin-bottom: 10px;
    }
    .highlight-area {
      position: absolute;
      background-color: rgba(0, 255, 0, 0.4);
      pointer-events: none;
      z-index: 10;
    }
    .outline-area {
      position: absolute;
      border: 2px solid rgba(0, 255, 0, 0.9);
      pointer-events: none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <h1>í‹€ë¦°ê·¸ë¦¼ì°¾ê¸° - ì´ë¯¸ì§€ ë¹„êµ</h1>
  
  <div class="controls file-inputs">
    <h3>ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ</h3>
    <div>
      <label for="original-file">ì›ë³¸ ì´ë¯¸ì§€ ì„ íƒ:</label>
      <input type="file" id="original-file" accept="image/*">
    </div>
    <div>
      <label for="modified-file">ìˆ˜ì •ëœ ì´ë¯¸ì§€ ì„ íƒ:</label>
      <input type="file" id="modified-file" accept="image/*">
    </div>
    <p>ë˜ëŠ” Supabase Storageì—ì„œ ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸°</p>
    <button id="use-default-urls">Storage ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸°</button>
  </div>
  
  <div class="images-container">
    <div class="image-wrapper">
      <h2>ì›ë³¸ ì´ë¯¸ì§€</h2>
      <div class="image-container" id="original-container">
        <img id="original-image" alt="ì›ë³¸ ì´ë¯¸ì§€">
      </div>
    </div>
    
    <div class="image-wrapper">
      <h2>ìˆ˜ì •ëœ ì´ë¯¸ì§€</h2>
      <div class="image-container" id="modified-container">
        <img id="modified-image" alt="ìˆ˜ì •ëœ ì´ë¯¸ì§€">
        <canvas id="result-canvas" class="result-canvas"></canvas>
      </div>
    </div>
  </div>
  
  <div class="controls">
    <h3>ìë™ í‹€ë¦° ë¶€ë¶„ ê°ì§€</h3>
    <div class="display-mode">
      <label>í‘œì‹œ ë°©ì‹:</label>
      <input type="radio" id="display-circle" name="display-mode" value="circle" checked>
      <label for="display-circle">ì›í˜• í‘œì‹œ</label>
      
      <input type="radio" id="display-pixel" name="display-mode" value="pixel">
      <label for="display-pixel">í”½ì…€ í‘œì‹œ</label>
      
      <input type="radio" id="display-pre-merge" name="display-mode" value="pre-merge">
      <label for="display-pre-merge">ë³‘í•© ì „ ì˜ì—­</label>
      
      <input type="radio" id="display-both" name="display-mode" value="both">
      <label for="display-both">ë³‘í•© ì „/í›„ ë¹„êµ</label>
    </div>
    <div class="threshold-controls">
      <label for="diff-threshold">ì°¨ì´ ê°ì§€ ë¯¼ê°ë„:</label>
      <input type="range" id="diff-threshold" min="1" max="100" value="30">
      <span id="threshold-value">30</span>
      
      <label for="min-area">ìµœì†Œ ì˜ì—­ í¬ê¸°:</label>
      <input type="range" id="min-area" min="10" max="1000" value="100">
      <span id="min-area-value">100</span>
      
      <label for="merge-distance">ì˜ì—­ ë³‘í•© ê±°ë¦¬:</label>
      <input type="range" id="merge-distance" min="0" max="200" value="50">
      <span id="merge-distance-value">50</span>
    </div>
    <button id="detect-differences" class="auto-detect">ìë™ìœ¼ë¡œ í‹€ë¦° ë¶€ë¶„ ì°¾ê¸°</button>
    <div class="status" id="detection-status"></div>
  </div>
  
  <div class="game-mode" id="game-section" style="display: none;">
    <h3>í‹€ë¦°ê·¸ë¦¼ì°¾ê¸° ê²Œì„ ëª¨ë“œ</h3>
    <p>í‹€ë¦° ë¶€ë¶„ì„ í´ë¦­í•˜ì—¬ ì°¾ì•„ë³´ì„¸ìš”!</p>
    
    <div class="answer-mode-options">
      <label>ì •ë‹µ í‘œì‹œ ë°©ì‹:</label>
      <input type="radio" id="answer-exact" name="answer-mode" value="exact" checked>
      <label for="answer-exact">ì •í™•í•œ ì˜ì—­</label>
      
      <input type="radio" id="answer-outline" name="answer-mode" value="outline">
      <label for="answer-outline">ì™¸ê³½ì„ ë§Œ</label>
      
      <input type="radio" id="answer-outline-dots" name="answer-mode" value="outline-dots">
      <label for="answer-outline-dots">ì™¸ê³½ì„ +ë‚´ë¶€ì </label>
    </div>
    
    <div>ì°¾ì€ ì •ë‹µ: <span id="found-count">0</span> / <span id="total-count">0</span></div>
    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill"></div>
    </div>
    <button id="start-game" class="auto-detect" style="margin-top: 15px;">ê²Œì„ ì‹œì‘í•˜ê¸°</button>
    <button id="show-answers" style="margin-top: 15px; display: none;">ì •ë‹µ ë³´ê¸°</button>
  </div>
  
  <div class="controls">
    <h3>ìˆ˜ë™ í‹€ë¦° ë¶€ë¶„ ì œì–´</h3>
    <button id="clear-points">ëª¨ë“  ì  ì§€ìš°ê¸°</button>
    <button id="remove-last">ë§ˆì§€ë§‰ ì  ì§€ìš°ê¸°</button>
    <button id="save-points">ì¢Œí‘œ ì €ì¥í•˜ê¸°</button>
    <button id="save-to-database" class="auto-detect">ë°ì´í„°ë² ì´ìŠ¤ì— ì •ë‹µ ì €ì¥</button>
  </div>
  
  <div class="controls" id="database-panel">
    <h3>ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìƒíƒœ</h3>
    <div>
      <label for="image-set-id">ì´ë¯¸ì§€ ì„¸íŠ¸ ID:</label>
      <input type="number" id="image-set-id" value="3" min="1" style="width: 100px;">
    </div>
    <div style="margin-top: 10px;">
      <button id="test-connection" class="auto-detect">ì—°ê²° í…ŒìŠ¤íŠ¸</button>
      <button id="create-tables" class="auto-detect">í…Œì´ë¸” ìƒì„±</button>
      <button id="load-image-sets" class="auto-detect">ì´ë¯¸ì§€ ì„¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸°</button>
    </div>
    <div id="connection-status" class="status"></div>
  </div>
  
  <div class="controls" id="image-sets-panel" style="display: none;">
    <h3>ì´ë¯¸ì§€ ì„¸íŠ¸ ì„ íƒ</h3>
    <div id="image-sets-container">
      <!-- ì´ë¯¸ì§€ ì„¸íŠ¸ ëª©ë¡ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
    </div>
  </div>
  
  <div class="data-display">
    <h3>í‹€ë¦° ë¶€ë¶„ ì¢Œí‘œ (JSON í˜•ì‹)</h3>
    <p>ìˆ˜ì •ëœ ì´ë¯¸ì§€ì—ì„œ í‹€ë¦° ë¶€ë¶„ì„ í´ë¦­í•˜ê±°ë‚˜ ìë™ìœ¼ë¡œ ê°ì§€í•˜ë©´ ì¢Œí‘œê°€ ê¸°ë¡ë©ë‹ˆë‹¤.</p>
    <textarea id="points-data" readonly></textarea>
  </div>
  
  <!-- ì´ë¯¸ì§€ ë¶„ì„ìš© ìº”ë²„ìŠ¤ -->
  <canvas id="analysis-canvas"></canvas>
  
  <div class="legend" id="color-legend" style="display: none;">
    <div class="legend-item">
      <div class="legend-color pre-merge"></div>
      <span>ë³‘í•© ì „ ì˜ì—­</span>
    </div>
    <div class="legend-item">
      <div class="legend-color post-merge"></div>
      <span>ë³‘í•© í›„ ì˜ì—­</span>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const originalContainer = document.getElementById('original-container');
      const modifiedContainer = document.getElementById('modified-container');
      const modifiedImage = document.getElementById('modified-image');
      const originalImage = document.getElementById('original-image');
      const pointsData = document.getElementById('points-data');
      const clearPointsBtn = document.getElementById('clear-points');
      const removeLastBtn = document.getElementById('remove-last');
      const savePointsBtn = document.getElementById('save-points');
      const detectDifferencesBtn = document.getElementById('detect-differences');
      const diffThreshold = document.getElementById('diff-threshold');
      const thresholdValue = document.getElementById('threshold-value');
      const minArea = document.getElementById('min-area');
      const minAreaValue = document.getElementById('min-area-value');
      const mergeDistance = document.getElementById('merge-distance');
      const mergeDistanceValue = document.getElementById('merge-distance-value');
      const detectionStatus = document.getElementById('detection-status');
      const analysisCanvas = document.getElementById('analysis-canvas');
      const resultCanvas = document.getElementById('result-canvas');
      const originalFileInput = document.getElementById('original-file');
      const modifiedFileInput = document.getElementById('modified-file');
      const useDefaultUrlsBtn = document.getElementById('use-default-urls');
      const displayCircleRadio = document.getElementById('display-circle');
      const displayPixelRadio = document.getElementById('display-pixel');
      const displayPreMergeRadio = document.getElementById('display-pre-merge');
      const displayBothRadio = document.getElementById('display-both');
      const colorLegend = document.getElementById('color-legend');
      const gameSection = document.getElementById('game-section');
      const startGameBtn = document.getElementById('start-game');
      const showAnswersBtn = document.getElementById('show-answers');
      const foundCountElem = document.getElementById('found-count');
      const totalCountElem = document.getElementById('total-count');
      const progressFill = document.getElementById('progress-fill');
      const answerExactRadio = document.getElementById('answer-exact');
      const answerOutlineRadio = document.getElementById('answer-outline');
      const answerOutlineDotsRadio = document.getElementById('answer-outline-dots');
      const saveToDatabaseBtn = document.getElementById('save-to-database');
      const imageSetIdInput = document.getElementById('image-set-id');
      const testConnectionBtn = document.getElementById('test-connection');
      const createTablesBtn = document.getElementById('create-tables');
      const loadImageSetsBtn = document.getElementById('load-image-sets');
      const connectionStatus = document.getElementById('connection-status');
      const imageSetsPanel = document.getElementById('image-sets-panel');
      const imageSetsContainer = document.getElementById('image-sets-container');
      
      let points = [];
      let imageWidth = 0;
      let imageHeight = 0;
      let allRegions = []; // ëª¨ë“  ì°¨ì´ì  ì˜ì—­ ì €ì¥ (ë³‘í•© í›„)
      let originalRegions = []; // ë³‘í•© ì „ ì›ë³¸ ì˜ì—­
      let differenceMap = null; // ì°¨ì´ì  ë§µ ì €ì¥
      let answerRegions = []; // ì •ë‹µ ì˜ì—­
      let foundAnswers = []; // ì°¾ì€ ì •ë‹µ ì˜ì—­
      let gameMode = false; // ê²Œì„ ëª¨ë“œ í™œì„±í™” ì—¬ë¶€
      
      // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ì´ë¯¸ì§€ ì„¸íŠ¸ ID ë¶ˆëŸ¬ì˜¤ê¸°
      if (localStorage.getItem('imageSetId')) {
        imageSetIdInput.value = localStorage.getItem('imageSetId');
      }
      
      // íŒŒì¼ ì—…ë¡œë“œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
      originalFileInput.addEventListener('change', function() {
        if (this.files && this.files[0]) {
          const reader = new FileReader();
          reader.onload = function(e) {
            originalImage.crossOrigin = "anonymous";
            originalImage.src = e.target.result;
            originalImage.onload = function() {
              console.log('ì›ë³¸ ì´ë¯¸ì§€ ë¡œë“œë¨:', this.naturalWidth, 'x', this.naturalHeight);
              updateImageDimensions();
            };
          };
          reader.readAsDataURL(this.files[0]);
        }
      });
      
      modifiedFileInput.addEventListener('change', function() {
        if (this.files && this.files[0]) {
          const reader = new FileReader();
          reader.onload = function(e) {
            modifiedImage.crossOrigin = "anonymous";
            modifiedImage.src = e.target.result;
            modifiedImage.onload = function() {
              console.log('ìˆ˜ì •ëœ ì´ë¯¸ì§€ ë¡œë“œë¨:', this.naturalWidth, 'x', this.naturalHeight);
              updateImageDimensions();
              setupCanvas();
            };
          };
          reader.readAsDataURL(this.files[0]);
        }
      });
      
      // ì´ë¯¸ì§€ í¬ê¸° ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (í•­ìƒ naturalSize ê¸°ì¤€)
      function updateImageDimensions() {
        if (originalImage.naturalWidth && modifiedImage.naturalWidth) {
          imageWidth = Math.max(originalImage.naturalWidth, modifiedImage.naturalWidth);
          imageHeight = Math.max(originalImage.naturalHeight, modifiedImage.naturalHeight);
          console.log('ğŸŒ ì´ë¯¸ì§€ naturalSize ì„¤ì •:', {
            ì›ë³¸: `${originalImage.naturalWidth}x${originalImage.naturalHeight}`,
            ìˆ˜ì •: `${modifiedImage.naturalWidth}x${modifiedImage.naturalHeight}`,
            ìµœì¢…: `${imageWidth}x${imageHeight}`,
            ìƒíƒœ: 'ì„±ê³µ'
          });
        } else {
          console.warn('âš ï¸ ì´ë¯¸ì§€ í¬ê¸° ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', {
            ì›ë³¸Loaded: !!originalImage.naturalWidth,
            ìˆ˜ì •Loaded: !!modifiedImage.naturalWidth
          });
        }
      }
      
      // ìº”ë²„ìŠ¤ ì„¤ì • í•¨ìˆ˜
      function setupCanvas() {
        // ê²°ê³¼ ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        const rect = modifiedImage.getBoundingClientRect();
        resultCanvas.width = rect.width;
        resultCanvas.height = rect.height;
        resultCanvas.style.width = rect.width + 'px';
        resultCanvas.style.height = rect.height + 'px';
        
        console.log('ìº”ë²„ìŠ¤ ì„¤ì • ì™„ë£Œ:', resultCanvas.width, 'x', resultCanvas.height);
      }
      
      // Supabase Storageì—ì„œ ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      useDefaultUrlsBtn.addEventListener('click', async function() {
        connectionStatus.textContent = 'Storageì—ì„œ ì´ë¯¸ì§€ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...';
        
        try {
          // ì„œë²„ì—ì„œ Storage ì´ë¯¸ì§€ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
          const response = await fetch('/api/storage/list-images');
          const data = await response.json();
          
          if (response.ok && data.original.length > 0 && data.modified.length > 0) {
            // ì²« ë²ˆì§¸ ì´ë¯¸ì§€ ìŒ ì‚¬ìš© (ë³´ì•ˆ ê°•í™”ë¥¼ ìœ„í•´ í”„ë¡ì‹œ URL ì‚¬ìš©)
            const originalUrl = `/api/storage/image/original/${data.original[0]}`;
            const modifiedUrl = `/api/storage/image/modified/${data.modified[0]}`;
            
            // ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ ì¹´ìš´í„°
            let imagesLoaded = 0;
            
            // ì›ë³¸ ì´ë¯¸ì§€ ë¡œë“œ ì´ë²¤íŠ¸ ì„¤ì •
            originalImage.onload = function() {
              console.log('Storage ì›ë³¸ ì´ë¯¸ì§€ ë¡œë“œë¨:', this.naturalWidth, 'x', this.naturalHeight);
              imagesLoaded++;
              if (imagesLoaded === 2) {
                updateImageDimensions();
        setupCanvas();
              }
            };
            
            // ìˆ˜ì •ëœ ì´ë¯¸ì§€ ë¡œë“œ ì´ë²¤íŠ¸ ì„¤ì •
            modifiedImage.onload = function() {
              console.log('Storage ìˆ˜ì •ëœ ì´ë¯¸ì§€ ë¡œë“œë¨:', this.naturalWidth, 'x', this.naturalHeight);
              imagesLoaded++;
              if (imagesLoaded === 2) {
                updateImageDimensions();
                setupCanvas();
              }
            };
            
            // CORS ì˜¤ë¥˜ ë°©ì§€ë¥¼ ìœ„í•´ crossOrigin ì„¤ì •
            originalImage.crossOrigin = "anonymous";
            modifiedImage.crossOrigin = "anonymous";
            
            // ì´ë¯¸ì§€ ì†ŒìŠ¤ ì„¤ì • (onload ì´ë²¤íŠ¸ ì„¤ì • í›„ì—)
            originalImage.src = originalUrl;
            modifiedImage.src = modifiedUrl;
            
            connectionStatus.textContent = `Storage ì´ë¯¸ì§€ ë¡œë“œë¨: ${data.original[0]}, ${data.modified[0]}`;
          } else {
            throw new Error('Storageì— ì´ë¯¸ì§€ê°€ ì—†ê±°ë‚˜ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨');
          }
        } catch (error) {
          console.error('Storage ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
          connectionStatus.textContent = 'Storage ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ' + error.message;
          
          // ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ ì‚¬ìš© (í”„ë¡ì‹œ URL)
          originalImage.src = '/api/storage/image/original/test.jpg';
          modifiedImage.src = '/api/storage/image/modified/test.jpg';
          connectionStatus.textContent = 'ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.';
        }
      });
      
      // ì—°ê²° í…ŒìŠ¤íŠ¸ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
      testConnectionBtn.addEventListener('click', async function() {
        connectionStatus.textContent = 'ì—°ê²° í…ŒìŠ¤íŠ¸ ì¤‘...';
        
        try {
          const response = await fetch('/api/status');
          const data = await response.json();
          
          if (response.ok) {
            connectionStatus.textContent = data.message + ` (í…Œì´ë¸” ìˆ˜: ${data.count})`;
          } else {
            throw new Error(data.error || 'Unknown error');
          }
        } catch (error) {
          console.error('ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì˜¤ë¥˜:', error);
          connectionStatus.textContent = 'ì—°ê²° ì‹¤íŒ¨: ' + error.message;
        }
      });
      
      // í…Œì´ë¸” ìƒì„± ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
      createTablesBtn.addEventListener('click', async function() {
        connectionStatus.textContent = 'í…Œì´ë¸” ìƒì„± ì¤‘...';
        
        try {
          const response = await fetch('/api/create-tables', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          const data = await response.json();
          
          if (response.ok) {
            connectionStatus.textContent = data.message;
            alert('í…Œì´ë¸”ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!');
          } else {
            throw new Error(data.error || 'Unknown error');
          }
        } catch (error) {
          console.error('í…Œì´ë¸” ìƒì„± ì˜¤ë¥˜:', error);
          connectionStatus.textContent = 'í…Œì´ë¸” ìƒì„± ì‹¤íŒ¨: ' + error.message;
          alert('í…Œì´ë¸” ìƒì„± ì‹¤íŒ¨: ' + error.message);
        }
      });
      
      // ì´ë¯¸ì§€ ì„¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
      loadImageSetsBtn.addEventListener('click', async function() {
        connectionStatus.textContent = 'ì´ë¯¸ì§€ ì„¸íŠ¸ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...';
        
        try {
          const response = await fetch('/api/image-sets');
          const data = await response.json();
          
          if (response.ok) {
            if (data && data.length > 0) {
              displayImageSets(data);
              connectionStatus.textContent = `${data.length}ê°œì˜ ì´ë¯¸ì§€ ì„¸íŠ¸ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`;
              imageSetsPanel.style.display = 'block';
            } else {
              connectionStatus.textContent = 'ì´ë¯¸ì§€ ì„¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.';
            }
          } else {
            throw new Error(data.error || 'Unknown error');
          }
        } catch (error) {
          console.error('ì´ë¯¸ì§€ ì„¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
          connectionStatus.textContent = 'ì´ë¯¸ì§€ ì„¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ' + error.message;
        }
      });
      
      // ì´ë¯¸ì§€ ì„¸íŠ¸ ëª©ë¡ í‘œì‹œ í•¨ìˆ˜
      function displayImageSets(imageSets) {
        imageSetsContainer.innerHTML = '';
        
        // í…Œì´ë¸” ìƒì„±
        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.borderCollapse = 'collapse';
        table.style.marginTop = '10px';
        
        // í—¤ë” í–‰ ìƒì„±
        const headerRow = document.createElement('tr');
        const headers = ['ID', 'ì œëª©', 'ì„¤ëª…', 'ì›ë³¸ ì´ë¯¸ì§€', 'ìˆ˜ì • ì´ë¯¸ì§€', 'ë™ì‘'];
        
        headers.forEach(headerText => {
          const th = document.createElement('th');
          th.textContent = headerText;
          th.style.padding = '8px';
          th.style.textAlign = 'left';
          th.style.borderBottom = '1px solid #ddd';
          headerRow.appendChild(th);
        });
        
        table.appendChild(headerRow);
        
        // ê° ì´ë¯¸ì§€ ì„¸íŠ¸ì— ëŒ€í•œ í–‰ ìƒì„±
        imageSets.forEach(set => {
          const row = document.createElement('tr');
          
          // ID ì—´
          const idCell = document.createElement('td');
          idCell.textContent = set.id;
          idCell.style.padding = '8px';
          idCell.style.borderBottom = '1px solid #ddd';
          row.appendChild(idCell);
          
          // ì œëª© ì—´
          const titleCell = document.createElement('td');
          titleCell.textContent = set.title || 'ì œëª© ì—†ìŒ';
          titleCell.style.padding = '8px';
          titleCell.style.borderBottom = '1px solid #ddd';
          row.appendChild(titleCell);
          
          // ì„¤ëª… ì—´
          const descCell = document.createElement('td');
          descCell.textContent = set.description || 'ì„¤ëª… ì—†ìŒ';
          descCell.style.padding = '8px';
          descCell.style.borderBottom = '1px solid #ddd';
          row.appendChild(descCell);
          
          // ì›ë³¸ ì´ë¯¸ì§€ ì—´
          const originalCell = document.createElement('td');
          originalCell.style.padding = '8px';
          originalCell.style.borderBottom = '1px solid #ddd';
                  if (set.original_image_url) {
          const img = document.createElement('img');
          img.src = set.original_image_url;
          img.style.maxHeight = '50px';
          img.style.cursor = 'pointer';
          img.title = 'í´ë¦­í•˜ì—¬ ì´ë¯¸ì§€ ë³´ê¸°';
          img.onclick = () => window.open(set.original_image_url, '_blank');
            originalCell.appendChild(img);
          } else {
            originalCell.textContent = 'ì´ë¯¸ì§€ ì—†ìŒ';
          }
          row.appendChild(originalCell);
          
          // ìˆ˜ì • ì´ë¯¸ì§€ ì—´
          const modifiedCell = document.createElement('td');
          modifiedCell.style.padding = '8px';
          modifiedCell.style.borderBottom = '1px solid #ddd';
                  if (set.modified_image_url) {
          const img = document.createElement('img');
          img.src = set.modified_image_url;
          img.style.maxHeight = '50px';
          img.style.cursor = 'pointer';
          img.title = 'í´ë¦­í•˜ì—¬ ì´ë¯¸ì§€ ë³´ê¸°';
          img.onclick = () => window.open(set.modified_image_url, '_blank');
            modifiedCell.appendChild(img);
          } else {
            modifiedCell.textContent = 'ì´ë¯¸ì§€ ì—†ìŒ';
          }
          row.appendChild(modifiedCell);
          
          // ë™ì‘ ì—´
          const actionCell = document.createElement('td');
          actionCell.style.padding = '8px';
          actionCell.style.borderBottom = '1px solid #ddd';
          
          const loadBtn = document.createElement('button');
          loadBtn.textContent = 'ì´ ì„¸íŠ¸ ì‚¬ìš©í•˜ê¸°';
          loadBtn.className = 'auto-detect';
          loadBtn.style.padding = '5px 10px';
          loadBtn.style.fontSize = '12px';
          loadBtn.onclick = () => loadImageSet(set);
          
          actionCell.appendChild(loadBtn);
          row.appendChild(actionCell);
          
          table.appendChild(row);
        });
        
        imageSetsContainer.appendChild(table);
      }
      
      // ì´ë¯¸ì§€ ì„¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° í•¨ìˆ˜
      async function loadImageSet(imageSet) {
        connectionStatus.textContent = 'ì´ë¯¸ì§€ ì„¸íŠ¸ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...';
        
        try {
          // CORS ë¬¸ì œ í•´ê²°ì„ ìœ„í•´ í”„ë¡ì‹œ URL ì‚¬ìš©
          if (imageSet.original_image_url) {
            // Storage URLì¸ì§€ í™•ì¸í•˜ê³  í”„ë¡ì‹œ ì‚¬ìš©
            if (imageSet.original_image_url.includes('/storage/v1/object/public/')) {
              originalImage.crossOrigin = 'anonymous';
              originalImage.src = '/api/storage/image/original/original.png';
            } else {
              originalImage.src = imageSet.original_image_url;
            }
          }
          
          if (imageSet.modified_image_url) {
            // Storage URLì¸ì§€ í™•ì¸í•˜ê³  í”„ë¡ì‹œ ì‚¬ìš©
            if (imageSet.modified_image_url.includes('/storage/v1/object/public/')) {
              modifiedImage.crossOrigin = 'anonymous';
              modifiedImage.src = '/api/storage/image/modified/modified.png';
            } else {
              modifiedImage.src = imageSet.modified_image_url;
            }
          }
          
          // ì´ë¯¸ì§€ ì„¸íŠ¸ ID ì €ì¥
          imageSetIdInput.value = imageSet.id;
          localStorage.setItem('imageSetId', imageSet.id);
          
          // ê¸°ì¡´ ì  ëª¨ë‘ ì œê±°
          clearPointsBtn.click();
          
          // ì •ë‹µ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
          await loadAnswerData(imageSet.id);
          
          connectionStatus.textContent = `ì´ë¯¸ì§€ ì„¸íŠ¸ ${imageSet.id} ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ`;
          
          // ì´ë¯¸ì§€ ì„¸íŠ¸ íŒ¨ë„ ìˆ¨ê¸°ê¸°
          imageSetsPanel.style.display = 'none';
        } catch (error) {
          console.error('ì´ë¯¸ì§€ ì„¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
          connectionStatus.textContent = 'ì´ë¯¸ì§€ ì„¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ' + error.message;
        }
      }
      
      // ì •ë‹µ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° í•¨ìˆ˜
      async function loadAnswerData(imageSetId) {
        try {
          const response = await fetch(`/api/answer-points/${imageSetId}`);
          const data = await response.json();
          
          if (response.ok) {
            if (data && data.image_set_id) {
              // ì›ë³¸ ë°ì´í„° í˜•ì‹ìœ¼ë¡œ ë³€í™˜
              const answerData = {
                image_set_id: data.image_set_id,
                image_width: data.image_width,
                image_height: data.image_height,
                points: data.points || []
              };
              
              // í™”ë©´ì— í‘œì‹œ
              console.log('ğŸ“Š DBì—ì„œ ë¶ˆëŸ¬ì˜¨ ë°ì´í„°:', {
                id: answerData.image_set_id,
                í¬ê¸°: `${answerData.image_width}x${answerData.image_height}`,
                points: answerData.points.length,
                regions: data.regions ? data.regions.length : 0
              });
              
              // ì´ë¯¸ì§€ í¬ê¸° ì •ë³´ ê²€ì¦ ë° ì„¤ì •
              if (answerData.image_width && answerData.image_height) {
                imageWidth = answerData.image_width;
                imageHeight = answerData.image_height;
              } else {
                console.warn('âš ï¸ DBì— ì´ë¯¸ì§€ í¬ê¸° ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ì´ë¯¸ì§€ì—ì„œ ìˆ˜ì§‘í•˜ì„¸ìš”.');
              }
              
              // ì •ë‹µ ë°ì´í„° ì„¤ì •
              if (data.regions) {
                allRegions = data.regions;
                detectionStatus.textContent = `${allRegions.length}ê°œì˜ ì •ë‹µ ì˜ì—­ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`;
                
                // ê²Œì„ ì„¹ì…˜ í‘œì‹œ
                gameSection.style.display = 'block';
              } else {
                detectionStatus.textContent = 'ì •ë‹µ ì˜ì—­ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.';
              }
              
              pointsData.value = JSON.stringify(answerData, null, 2);
            } else {
              detectionStatus.textContent = 'ì´ ì´ë¯¸ì§€ ì„¸íŠ¸ì— ëŒ€í•œ ì •ë‹µ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.';
            }
          } else {
            throw new Error(data.error || 'Unknown error');
          }
        } catch (error) {
          console.error('ì •ë‹µ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
          detectionStatus.textContent = 'ì •ë‹µ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ' + error.message;
        }
      }
      
      // ê²Œì„ ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ ìˆ˜ì •
      startGameBtn.addEventListener('click', function() {
        // ì •ë‹µ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
        if (allRegions.length === 0) {
          alert('ë¨¼ì € ìë™ìœ¼ë¡œ í‹€ë¦° ë¶€ë¶„ì„ ì°¾ê±°ë‚˜ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì´ë¯¸ì§€ ì„¸íŠ¸ë¥¼ ë¡œë“œí•´ì£¼ì„¸ìš”!');
          return;
        }
        
        // ê²Œì„ ëª¨ë“œ ì‹œì‘
        gameMode = true;
        
        // ì •ë‹µ ì˜ì—­ ì„¤ì • (ë³‘í•© í›„ ì˜ì—­ ì‚¬ìš©)
        answerRegions = [...allRegions];
        foundAnswers = new Array(answerRegions.length).fill(false);
        
        // ì¹´ìš´í„° ì—…ë°ì´íŠ¸
        totalCountElem.textContent = answerRegions.length;
        foundCountElem.textContent = '0';
        progressFill.style.width = '0%';
        
        // í™”ë©´ ì´ˆê¸°í™”
        clearPointsBtn.click();
        
        // ë²„íŠ¼ ìƒíƒœ ë³€ê²½
        startGameBtn.textContent = 'ê²Œì„ ì¬ì‹œì‘';
        showAnswersBtn.style.display = 'inline-block';
        
        // íŒíŠ¸ í‘œì‹œ ì˜µì…˜ ì¶”ê°€
        const showHintBtn = document.getElementById('show-hint-btn') || document.createElement('button');
        if (!document.getElementById('show-hint-btn')) {
          showHintBtn.id = 'show-hint-btn';
          showHintBtn.textContent = 'íŒíŠ¸ ë³´ê¸°';
          showHintBtn.style.marginTop = '15px';
          showHintBtn.style.marginLeft = '10px';
          showHintBtn.addEventListener('click', showHintMap);
          showAnswersBtn.parentNode.insertBefore(showHintBtn, showAnswersBtn.nextSibling);
        }
        
        detectionStatus.textContent = 'ê²Œì„ ëª¨ë“œê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. í‹€ë¦° ë¶€ë¶„ì„ í´ë¦­í•˜ì—¬ ì°¾ì•„ë³´ì„¸ìš”!';
      });
      
      // íŒíŠ¸ë§µ í‘œì‹œ í•¨ìˆ˜
      function showHintMap() {
        // ìº”ë²„ìŠ¤ ìƒì„±
        const canvas = document.createElement('canvas');
        const rect = modifiedImage.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        canvas.style.position = 'absolute';
        canvas.style.left = '0';
        canvas.style.top = '0';
        canvas.style.pointerEvents = 'none';
        canvas.style.zIndex = '5';
        
        const ctx = canvas.getContext('2d');
        
        // íˆíŠ¸ë§µ ê·¸ë¦¬ê¸°
        for (let i = 0; i < answerRegions.length; i++) {
          if (!foundAnswers[i]) {
            const region = answerRegions[i];
            
            // ì˜ì—­ì˜ ê²½ê³„ ê³„ì‚°
            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
            
            for (const pixel of region) {
              minX = Math.min(minX, pixel.x);
              minY = Math.min(minY, pixel.y);
              maxX = Math.max(maxX, pixel.x);
              maxY = Math.max(maxY, pixel.y);
            }
            
            // ì˜ì—­ì˜ ì¤‘ì‹¬ì  ê³„ì‚°
            const centerX = Math.round((minX + maxX) / 2);
            const centerY = Math.round((minY + maxY) / 2);
            
            // ì˜ì—­ì˜ í¬ê¸° ê³„ì‚°
            const width = maxX - minX;
            const height = maxY - minY;
            
            // í™”ë©´ í¬ê¸°ì— ë§ê²Œ ìŠ¤ì¼€ì¼ë§
            const scaleX = rect.width / imageWidth;
            const scaleY = rect.height / imageHeight;
            
            // ì¤‘ì‹¬ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ë¹¨ê°„ìƒ‰, ë©€ì–´ì§ˆìˆ˜ë¡ íˆ¬ëª…í•´ì§€ëŠ” ì›í˜• ê·¸ë¼ë°ì´ì…˜
            const radius = Math.max(width, height) * 0.5 * Math.max(scaleX, scaleY);
            const gradient = ctx.createRadialGradient(
              centerX * scaleX, centerY * scaleY, 0,
              centerX * scaleX, centerY * scaleY, radius
            );
            
            gradient.addColorStop(0, 'rgba(255, 0, 0, 0.3)');
            gradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX * scaleX, centerY * scaleY, radius, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // ê¸°ì¡´ íŒíŠ¸ë§µ ì œê±°
        const oldHintMap = document.getElementById('hint-map');
        if (oldHintMap) {
          oldHintMap.remove();
        }
        
        // íŒíŠ¸ë§µ ì¶”ê°€
        canvas.id = 'hint-map';
        modifiedContainer.appendChild(canvas);
        
        // 5ì´ˆ í›„ íŒíŠ¸ë§µ ì œê±°
        setTimeout(() => {
          if (document.getElementById('hint-map')) {
            document.getElementById('hint-map').remove();
          }
        }, 5000);
        
        detectionStatus.textContent = 'íŒíŠ¸ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤. 5ì´ˆ í›„ ìë™ìœ¼ë¡œ ì‚¬ë¼ì§‘ë‹ˆë‹¤.';
      }

      // ì •ë‹µ ë³´ê¸° ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
      showAnswersBtn.addEventListener('click', function() {
        // ëª¨ë“  ì •ë‹µ í‘œì‹œ
        showAllAnswers();
      });

      // ëª¨ë“  ì •ë‹µ í‘œì‹œ
      function showAllAnswers() {
        // ì´ë¯¸ ì°¾ì€ ì •ë‹µì€ ì œì™¸í•˜ê³  ë‚˜ë¨¸ì§€ë§Œ í‘œì‹œ
        for (let i = 0; i < answerRegions.length; i++) {
          if (!foundAnswers[i]) {
            // ì •ë‹µ í‘œì‹œ ë°©ì‹ì— ë”°ë¼ ë‹¤ë¥´ê²Œ í‘œì‹œ
            if (answerExactRadio.checked) {
              // ì •í™•í•œ ì˜ì—­ í‘œì‹œ ëª¨ë“œ
              showExactAnswer(answerRegions[i]);
            } else if (answerOutlineRadio.checked) {
              // ì™¸ê³½ì„  í‘œì‹œ ëª¨ë“œ
              showOutlineAnswer(answerRegions[i]);
            } else if (answerOutlineDotsRadio.checked) {
              // ì™¸ê³½ì„ +ë‚´ë¶€ì  í‘œì‹œ ëª¨ë“œ
              showOutlineAnswer(answerRegions[i]);
            }
            
            // ì´ë¯¸ ì°¾ì€ ê²ƒìœ¼ë¡œ í‘œì‹œ
            foundAnswers[i] = true;
          }
        }
        
        // ê²Œì„ ì¢…ë£Œ ìƒíƒœë¡œ ë³€ê²½
        foundCountElem.textContent = answerRegions.length;
        progressFill.style.width = '100%';
        detectionStatus.textContent = 'ëª¨ë“  ì •ë‹µì´ í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤.';
      }

      // ì •í™•í•œ ì˜ì—­ ëª¨ì–‘ìœ¼ë¡œ ì •ë‹µ í‘œì‹œ
      function showExactAnswer(region) {
        const rect = modifiedImage.getBoundingClientRect();
        const scaleX = rect.width / imageWidth;
        const scaleY = rect.height / imageHeight;
        
        // ì˜ì—­ì˜ ê²½ê³„ ê³„ì‚°
        let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
        
        for (const pixel of region) {
          minX = Math.min(minX, pixel.x);
          minY = Math.min(minY, pixel.y);
          maxX = Math.max(maxX, pixel.x);
          maxY = Math.max(maxY, pixel.y);
        }
        
        // ìº”ë²„ìŠ¤ ìƒì„±
        const canvas = document.createElement('canvas');
        canvas.width = (maxX - minX + 10) * scaleX;
        canvas.height = (maxY - minY + 10) * scaleY;
        canvas.style.position = 'absolute';
        canvas.style.left = (minX - 5) * scaleX + 'px';
        canvas.style.top = (minY - 5) * scaleY + 'px';
        canvas.style.pointerEvents = 'none';
        canvas.style.zIndex = '10';
        
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
        
        // ì˜ì—­ ê·¸ë¦¬ê¸°
        for (const pixel of region) {
          const x = (pixel.x - minX + 5) * scaleX;
          const y = (pixel.y - minY + 5) * scaleY;
          const pixelSize = Math.max(2, Math.min(scaleX, scaleY) * 2);
          ctx.fillRect(x - pixelSize/2, y - pixelSize/2, pixelSize, pixelSize);
        }
        
        modifiedContainer.appendChild(canvas);
      }

      // ì™¸ê³½ì„ ìœ¼ë¡œ ì •ë‹µ í‘œì‹œ í•¨ìˆ˜ ê°œì„ 
      function showOutlineAnswer(region) {
        const rect = modifiedImage.getBoundingClientRect();
        const scaleX = rect.width / imageWidth;
        const scaleY = rect.height / imageHeight;
        
        // ì˜ì—­ì˜ ê²½ê³„ ê³„ì‚°
        let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
        
        for (const pixel of region) {
          minX = Math.min(minX, pixel.x);
          minY = Math.min(minY, pixel.y);
          maxX = Math.max(maxX, pixel.x);
          maxY = Math.max(maxY, pixel.y);
        }
        
        // ì˜ì—­ í¬ê¸°ì— ì•½ê°„ì˜ ì—¬ìœ  ì¶”ê°€
        const padding = 5;
        minX = Math.max(0, minX - padding);
        minY = Math.max(0, minY - padding);
        maxX = Math.min(imageWidth - 1, maxX + padding);
        maxY = Math.min(imageHeight - 1, maxY + padding);
        
        const width = maxX - minX + 1;
        const height = maxY - minY + 1;
        
        // í”½ì…€ ë§µ ìƒì„± (í•´ë‹¹ ìœ„ì¹˜ì— í”½ì…€ì´ ìˆëŠ”ì§€ ì—¬ë¶€)
        const pixelMap = new Array(width * height).fill(0);
        
        for (const pixel of region) {
          const x = pixel.x - minX;
          const y = pixel.y - minY;
          if (x >= 0 && x < width && y >= 0 && y < height) {
            pixelMap[y * width + x] = 1;
          }
        }
        
        // ìº”ë²„ìŠ¤ ìƒì„±
        const canvas = document.createElement('canvas');
        canvas.width = rect.width;
        canvas.height = rect.height;
        canvas.style.position = 'absolute';
        canvas.style.left = '0';
        canvas.style.top = '0';
        canvas.style.pointerEvents = 'none';
        canvas.style.zIndex = '10';
        
        const ctx = canvas.getContext('2d');
        
        // ë°©í–¥ ë°°ì—´ (ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 8ê°œ ë°©í–¥)
        const directions = [
          {dx: 1, dy: 0},   // ì˜¤ë¥¸ìª½
          {dx: 1, dy: 1},   // ì˜¤ë¥¸ìª½ ì•„ë˜
          {dx: 0, dy: 1},   // ì•„ë˜
          {dx: -1, dy: 1},  // ì™¼ìª½ ì•„ë˜
          {dx: -1, dy: 0},  // ì™¼ìª½
          {dx: -1, dy: -1}, // ì™¼ìª½ ìœ„
          {dx: 0, dy: -1},  // ìœ„
          {dx: 1, dy: -1}   // ì˜¤ë¥¸ìª½ ìœ„
        ];
        
        // ì™¸ê³½ì„  ì¶”ì  ì•Œê³ ë¦¬ì¦˜ (Moore Boundary Tracing)
        function traceContour(startX, startY) {
          const contour = [];
          let x = startX;
          let y = startY;
          let dirIndex = 0; // ì‹œì‘ ë°©í–¥ (ì˜¤ë¥¸ìª½)
          
          // ì‹œì‘ì  ì¶”ê°€
          contour.push({x, y});
          
          // ì²« ë²ˆì§¸ ì™¸ê³½ì„  í”½ì…€ ì°¾ê¸°
          let foundBoundary = false;
          for (let i = 0; i < directions.length; i++) {
            const nx = x + directions[i].dx;
            const ny = y + directions[i].dy;
            
            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
              if (pixelMap[ny * width + nx] === 1) {
                x = nx;
                y = ny;
                dirIndex = (i + 5) % 8; // ì´ì „ ë°©í–¥ì˜ ë°˜ëŒ€í¸ë¶€í„° ì‹œì‘
                contour.push({x, y});
                foundBoundary = true;
                break;
              }
            }
          }
          
          if (!foundBoundary) return contour;
          
          const startPixel = {x, y};
          let currentPixel = {x, y};
          let previousDirIndex = dirIndex;
          
          // ì™¸ê³½ì„  ë”°ë¼ê°€ê¸°
          do {
            // í˜„ì¬ ë°©í–¥ë¶€í„° ë°˜ì‹œê³„ ë°©í–¥ìœ¼ë¡œ ì¸ì ‘ í”½ì…€ ê²€ì‚¬
            let found = false;
            
            for (let i = 0; i < directions.length; i++) {
              // ì´ì „ ë°©í–¥ì—ì„œ ë°˜ì‹œê³„ ë°©í–¥ìœ¼ë¡œ ê²€ìƒ‰
              const searchDirIndex = (previousDirIndex + i) % 8;
              const dir = directions[searchDirIndex];
              
              const nx = currentPixel.x + dir.dx;
              const ny = currentPixel.y + dir.dy;
              
              if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                if (pixelMap[ny * width + nx] === 1) {
                  // ì™¸ê³½ì„  í”½ì…€ ë°œê²¬
                  currentPixel = {x: nx, y: ny};
                  contour.push(currentPixel);
                  previousDirIndex = (searchDirIndex + 4) % 8; // ì´ë™í•œ ë°©í–¥ì˜ ë°˜ëŒ€í¸
                  found = true;
                  break;
                }
              }
            }
            
            if (!found) break;
            
            // ì‹œì‘ì ìœ¼ë¡œ ëŒì•„ì™”ëŠ”ì§€ í™•ì¸
          } while (!(currentPixel.x === startPixel.x && currentPixel.y === startPixel.y) || contour.length <= 2);
          
          return contour;
        }
        
        // ì™¸ê³½ì„  ì°¾ê¸°
        const contours = [];
        const visited = new Array(width * height).fill(0);
        
        // ì²« ë²ˆì§¸ í”½ì…€ ì°¾ê¸°
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const index = y * width + x;
            
            if (pixelMap[index] === 1 && visited[index] === 0) {
              // ì™¸ê³½ì„  í›„ë³´ í”½ì…€ ë°œê²¬
              // ì£¼ë³€ì— ë¹ˆ í”½ì…€ì´ ìˆëŠ”ì§€ í™•ì¸ (ì™¸ê³½ì„  ì¡°ê±´)
              let isBoundary = false;
              
              for (const dir of directions) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;
                
                if (nx < 0 || nx >= width || ny < 0 || ny >= height || pixelMap[ny * width + nx] === 0) {
                  isBoundary = true;
                  break;
                }
              }
              
              if (isBoundary) {
                const contour = traceContour(x, y);
                
                // ë„ˆë¬´ ì‘ì€ ì™¸ê³½ì„  ë¬´ì‹œ
                if (contour.length >= 5) {
                  contours.push(contour);
                  
                  // ë°©ë¬¸í•œ í”½ì…€ í‘œì‹œ
                  for (const pixel of contour) {
                    visited[pixel.y * width + pixel.x] = 1;
                  }
                }
              }
            }
          }
        }
        
        // ì™¸ê³½ì„  ê·¸ë¦¬ê¸°
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.9)';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        for (const contour of contours) {
          if (contour.length < 2) continue;
          
          ctx.beginPath();
          
          // ì²« ì ìœ¼ë¡œ ì´ë™
          const firstPixel = contour[0];
          ctx.moveTo(
            (firstPixel.x + minX) * scaleX,
            (firstPixel.y + minY) * scaleY
          );
          
          // ë‚˜ë¨¸ì§€ ì ë“¤ ì—°ê²°
          for (let i = 1; i < contour.length; i++) {
            const pixel = contour[i];
            ctx.lineTo(
              (pixel.x + minX) * scaleX,
              (pixel.y + minY) * scaleY
            );
          }
          
          // ì™¸ê³½ì„  ë‹«ê¸°
          ctx.closePath();
          ctx.stroke();
          
          // ì˜µì…˜ì— ë”°ë¼ ë‚´ë¶€ ì²˜ë¦¬
          if (answerOutlineDotsRadio && answerOutlineDotsRadio.checked) {
            // ë‚´ë¶€ í”½ì…€ ì ìœ¼ë¡œ í‘œì‹œ (ë‚´ë¶€ì— ì–´ë–¤ í”½ì…€ì´ ìˆëŠ”ì§€ ë³´ì—¬ì¤Œ)
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                if (pixelMap[y * width + x] === 1) {
                  // ì´ë¯¸ ë°©ë¬¸í•œ ì™¸ê³½ì„  í”½ì…€ì€ ê±´ë„ˆë›°ê¸°
                  if (visited[y * width + x] === 1) continue;
                  
                  // ë‚´ë¶€ í”½ì…€ë§Œ ì‘ì€ ì ìœ¼ë¡œ í‘œì‹œ
                  const displayX = (x + minX) * scaleX;
                  const displayY = (y + minY) * scaleY;
                  const dotSize = 2;
                  
                  ctx.beginPath();
                  ctx.arc(displayX, displayY, dotSize, 0, Math.PI * 2);
                  ctx.fill();
                }
              }
            }
          }
        }
        
        // ê²°ê³¼ë¬¼ì´ ë¹„ì–´ìˆë‹¤ë©´ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ëŒ€ì²´
        if (contours.length === 0) {
          ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
          
          for (const pixel of region) {
            const x = pixel.x * scaleX;
            const y = pixel.y * scaleY;
            const pixelSize = Math.max(2, Math.min(scaleX, scaleY) * 2);
            ctx.fillRect(x - pixelSize/2, y - pixelSize/2, pixelSize, pixelSize);
          }
        }
        
        modifiedContainer.appendChild(canvas);
      }

      // ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
      function calculateDistance(point1, point2) {
        return Math.sqrt(
          Math.pow(point1.x - point2.x, 2) + 
          Math.pow(point1.y - point2.y, 2)
        );
      }

      // ë‘ ì˜ì—­ì´ ì„œë¡œ ê²¹ì¹˜ê±°ë‚˜ ê·¼ì ‘í•œì§€ í™•ì¸
      function areRegionsClose(region1, region2, maxDistance) {
        // ëª¨ë“  ì  ì¡°í•©ì— ëŒ€í•´ ìµœì†Œ ê±°ë¦¬ ì°¾ê¸°
        for (const pixel1 of region1) {
          for (const pixel2 of region2) {
            const distance = calculateDistance(pixel1, pixel2);
            if (distance <= maxDistance) {
              return true;
            }
          }
        }
        return false;
      }

      // ì˜ì—­ë“¤ì„ ë³‘í•©
      function mergeRegions(regions, maxDistance) {
        if (regions.length <= 1) return regions;
        
        let merged = true;
        let mergedRegions = [...regions];
        
        // ë” ì´ìƒ ë³‘í•©í•  ì˜ì—­ì´ ì—†ì„ ë•Œê¹Œì§€ ë°˜ë³µ
        while (merged) {
          merged = false;
          
          // í˜„ì¬ ì˜ì—­ ëª©ë¡ ë³µì‚¬
          const currentRegions = [...mergedRegions];
          mergedRegions = [];
          
          // ì´ë¯¸ ë³‘í•©ëœ ì˜ì—­ ì¶”ì 
          const processedIndices = new Set();
          
          for (let i = 0; i < currentRegions.length; i++) {
            if (processedIndices.has(i)) continue;
            
            let mergedRegion = [...currentRegions[i]];
            processedIndices.add(i);
            
            // ë‹¤ë¥¸ ëª¨ë“  ì˜ì—­ê³¼ ë¹„êµ
            for (let j = 0; j < currentRegions.length; j++) {
              if (i === j || processedIndices.has(j)) continue;
              
              // ë‘ ì˜ì—­ì´ ì¶©ë¶„íˆ ê°€ê¹Œìš°ë©´ ë³‘í•©
              if (areRegionsClose(mergedRegion, currentRegions[j], maxDistance)) {
                mergedRegion = [...mergedRegion, ...currentRegions[j]];
                processedIndices.add(j);
                merged = true;
              }
            }
            
            mergedRegions.push(mergedRegion);
          }
        }
        
        return mergedRegions;
      }

      // ì´ë¯¸ì§€ ì°¨ì´ì  ê°ì§€ í•¨ìˆ˜ (í•­ìƒ naturalSize ê¸°ì¤€)
      async function detectDifferences() {
        // ìº”ë²„ìŠ¤ ì„¤ì • (naturalSize ê¸°ì¤€)
        const ctx = analysisCanvas.getContext('2d');
        analysisCanvas.width = imageWidth;
        analysisCanvas.height = imageHeight;
        
        console.log('ğŸ” ë¶„ì„ ì‹œì‘:', {
          ìº”ë²„ìŠ¤í¬ê¸°: `${imageWidth}x${imageHeight}`,
          ì›ë³¸naturalSize: `${originalImage.naturalWidth}x${originalImage.naturalHeight}`,
          ìˆ˜ì •naturalSize: `${modifiedImage.naturalWidth}x${modifiedImage.naturalHeight}`,
          ê¸°ì¤€: 'naturalSize'
        });
        
        let originalData, modifiedData;
        
        try {
        // ì›ë³¸ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        ctx.drawImage(originalImage, 0, 0, imageWidth, imageHeight);
          originalData = ctx.getImageData(0, 0, imageWidth, imageHeight);
        
        // ìˆ˜ì •ëœ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        ctx.clearRect(0, 0, imageWidth, imageHeight);
        ctx.drawImage(modifiedImage, 0, 0, imageWidth, imageHeight);
          modifiedData = ctx.getImageData(0, 0, imageWidth, imageHeight);
        } catch (corsError) {
          console.log('CORS ì˜¤ë¥˜ ë°œìƒ, ì„œë²„ í”„ë¡ì‹œë¥¼ í†µí•´ ì´ë¯¸ì§€ ì¬ë¡œë“œ ì‹œë„...');
          
          // CORS ì˜¤ë¥˜ ì‹œ ì„œë²„ì—ì„œ ì´ë¯¸ì§€ë¥¼ ë‹¤ì‹œ ë¡œë“œ (ë™ì  URL ì²˜ë¦¬)
          const originalProxyUrl = originalImage.src.includes('supabase.co') ? 
            originalImage.src.replace(/https:\/\/[a-z0-9]+\.supabase\.co\/storage\/v1\/object\/public\//, '/api/storage/image/') :
            originalImage.src;
          const modifiedProxyUrl = modifiedImage.src.includes('supabase.co') ?
            modifiedImage.src.replace(/https:\/\/[a-z0-9]+\.supabase\.co\/storage\/v1\/object\/public\//, '/api/storage/image/') :
            modifiedImage.src;
          
          // ì„ì‹œ ì´ë¯¸ì§€ ìš”ì†Œ ìƒì„±
          const tempOriginal = new Image();
          const tempModified = new Image();
          tempOriginal.crossOrigin = "anonymous";
          tempModified.crossOrigin = "anonymous";
          
          // í”„ë¡ì‹œë¥¼ í†µí•œ ì´ë¯¸ì§€ ë¡œë“œ ëŒ€ê¸°
          await new Promise((resolve, reject) => {
            let loadedCount = 0;
            
            tempOriginal.onload = () => {
              loadedCount++;
              if (loadedCount === 2) resolve();
            };
            
            tempModified.onload = () => {
              loadedCount++;
              if (loadedCount === 2) resolve();
            };
            
            tempOriginal.onerror = tempModified.onerror = reject;
            
            tempOriginal.src = originalProxyUrl;
            tempModified.src = modifiedProxyUrl;
          });
          
          // ìº”ë²„ìŠ¤ì— í”„ë¡ì‹œ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
          ctx.drawImage(tempOriginal, 0, 0, imageWidth, imageHeight);
          originalData = ctx.getImageData(0, 0, imageWidth, imageHeight);
          
          ctx.clearRect(0, 0, imageWidth, imageHeight);
          ctx.drawImage(tempModified, 0, 0, imageWidth, imageHeight);
          modifiedData = ctx.getImageData(0, 0, imageWidth, imageHeight);
        }
        
        // ì°¨ì´ì  ê°ì§€ë¥¼ ìœ„í•œ ì„ê³„ê°’
        const threshold = parseInt(diffThreshold.value);
        const minAreaSize = parseInt(minArea.value);
        const maxMergeDistance = parseInt(mergeDistance.value);
        
        // ì°¨ì´ì  ê°ì§€ ë§µ ìƒì„±
        const differenceMap = new Uint8Array(imageWidth * imageHeight);
        let totalDiffPixels = 0;
        
        // ê° í”½ì…€ ë¹„êµ
        for (let i = 0; i < originalData.data.length; i += 4) {
          const r1 = originalData.data[i];
          const g1 = originalData.data[i + 1];
          const b1 = originalData.data[i + 2];
          
          const r2 = modifiedData.data[i];
          const g2 = modifiedData.data[i + 1];
          const b2 = modifiedData.data[i + 2];
          
          // ìƒ‰ìƒ ì°¨ì´ ê³„ì‚°
          const diff = Math.sqrt(
            Math.pow(r1 - r2, 2) +
            Math.pow(g1 - g2, 2) +
            Math.pow(b1 - b2, 2)
          );
          
          const pixelIndex = i / 4;
          if (diff > threshold) {
            differenceMap[pixelIndex] = 1;
            totalDiffPixels++;
          } else {
            differenceMap[pixelIndex] = 0;
          }
        }
        
        console.log(`ì„ê³„ê°’ ${threshold}ë¡œ ${totalDiffPixels}ê°œì˜ í”½ì…€ ì°¨ì´ ê°ì§€ë¨`);
        
        // ì—°ê²°ëœ ì˜ì—­ ì°¾ê¸° (Flood Fill ì•Œê³ ë¦¬ì¦˜)
        let regions = [];
        const visited = new Uint8Array(imageWidth * imageHeight);
        
        for (let y = 0; y < imageHeight; y++) {
          for (let x = 0; x < imageWidth; x++) {
            const index = y * imageWidth + x;
            
            if (differenceMap[index] === 1 && visited[index] === 0) {
              // ìƒˆë¡œìš´ ì—°ê²°ëœ ì˜ì—­ ì‹œì‘
              const region = [];
              const queue = [{x, y}];
              visited[index] = 1;
              
              // BFSë¡œ ì—°ê²°ëœ í”½ì…€ íƒìƒ‰
              while (queue.length > 0) {
                const current = queue.shift();
                region.push(current);
                
                // 8ë°©í–¥ ì¸ì ‘ í”½ì…€ í™•ì¸
                const directions = [
                  {dx: -1, dy: -1}, {dx: 0, dy: -1}, {dx: 1, dy: -1},
                  {dx: -1, dy: 0}, {dx: 1, dy: 0},
                  {dx: -1, dy: 1}, {dx: 0, dy: 1}, {dx: 1, dy: 1}
                ];
                
                for (const dir of directions) {
                  const nx = current.x + dir.dx;
                  const ny = current.y + dir.dy;
                  
                  if (nx >= 0 && nx < imageWidth && ny >= 0 && ny < imageHeight) {
                    const neighborIndex = ny * imageWidth + nx;
                    
                    if (differenceMap[neighborIndex] === 1 && visited[neighborIndex] === 0) {
                      queue.push({x: nx, y: ny});
                      visited[neighborIndex] = 1;
                    }
                  }
                }
              }
              
              // ì¶©ë¶„íˆ í° ì˜ì—­ë§Œ ì €ì¥
              if (region.length >= minAreaSize) {
                regions.push(region);
              }
            }
          }
        }
        
        console.log(`í•„í„°ë§ ì „ ${regions.length}ê°œì˜ ì˜ì—­ ê°ì§€ë¨`);
        
        // ë³‘í•© ì „ ì›ë³¸ ì˜ì—­ ì €ì¥
        const originalRegions = [...regions];
        
        // ì˜ì—­ ë³‘í•© (ê·¼ì ‘í•œ ì˜ì—­ë“¤ì„ í•˜ë‚˜ë¡œ í•©ì¹¨)
        regions = mergeRegions(regions, maxMergeDistance);
        console.log(`ì˜ì—­ ë³‘í•© í›„: ${regions.length}ê°œ ê°ì§€ (ë³‘í•© ì „: ${originalRegions.length}ê°œ)`);
        
        return {
          count: regions.length,
          originalRegions: originalRegions, // ë³‘í•© ì „ ì˜ì—­
          regions: regions,                 // ë³‘í•© í›„ ì˜ì—­
          differenceMap: differenceMap,
          pixelCount: totalDiffPixels
        };
      }

      saveToDatabaseBtn.addEventListener('click', async function() {
        // ì €ì¥í•  ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
        if (allRegions.length === 0) {
          alert('ë¨¼ì € ìë™ìœ¼ë¡œ í‹€ë¦° ë¶€ë¶„ì„ ì°¾ì•„ì£¼ì„¸ìš”!');
          return;
        }
        
        const imageSetId = parseInt(imageSetIdInput.value);
        if (!imageSetId || imageSetId <= 0) {
          alert('ì˜¬ë°”ë¥¸ ì´ë¯¸ì§€ ì„¸íŠ¸ IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!');
          return;
        }
        
        // ì´ë¯¸ì§€ í¬ê¸° ì •ë³´ ê²€ì¦
        if (!imageWidth || !imageHeight || imageWidth <= 0 || imageHeight <= 0) {
          alert('ì´ë¯¸ì§€ í¬ê¸° ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ë¯¸ì§€ë¥¼ ë‹¤ì‹œ ë¡œë“œí•´ì£¼ì„¸ìš”.');
          console.error('ì´ë¯¸ì§€ í¬ê¸° ì˜¤ë¥˜:', { imageWidth, imageHeight });
          return;
        }
        
        // ì €ì¥í•  ë°ì´í„° êµ¬ì„± (ìµœì í™”)
        const optimizedRegions = allRegions.map(region => {
          // ì˜ì—­ì´ ë„ˆë¬´ í¬ë©´ ìƒ˜í”Œë§í•˜ì—¬ í¬ê¸° ì¤„ì´ê¸°
          if (region.length > 1000) {
            // ì˜ì—­ì„ 10%ë¡œ ìƒ˜í”Œë§
            const step = Math.ceil(region.length / 100);
            return region.filter((_, index) => index % step === 0);
          }
          return region;
        });
        
        const saveData = {
          image_set_id: imageSetId,
          image_width: imageWidth,
          image_height: imageHeight,
          points: points,
          regions: optimizedRegions,
          created_at: new Date().toISOString()
        };
        // ë°ì´í„° í¬ê¸° í™•ì¸
        const dataSize = JSON.stringify(saveData).length;
        console.log('ì €ì¥í•  ë°ì´í„° í¬ê¸°:', (dataSize / 1024 / 1024).toFixed(2) + 'MB');
        console.log('ğŸ’¾ DB ì €ì¥ ë°ì´í„°:', {
          imageSetId: saveData.image_set_id,
          imageSize: `${saveData.image_width}x${saveData.image_height}`,
          regions: saveData.regions.length + 'ê°œ',
          points: saveData.points.length + 'ê°œ'
        });
        
        try {
          // ë²„íŠ¼ ë¹„í™œì„±í™” ë° ë¡œë”© í‘œì‹œ
          saveToDatabaseBtn.disabled = true;
          saveToDatabaseBtn.textContent = 'ì €ì¥ ì¤‘...';
          detectionStatus.textContent = 'ë°ì´í„°ë² ì´ìŠ¤ì— ì •ë‹µ ë°ì´í„° ì €ì¥ ì¤‘...';
          const response = await fetch('/api/answer-points', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(saveData)
          });
          
          // ì‘ë‹µ ìƒíƒœ í™•ì¸
          if (!response.ok) {
            if (response.status === 413) {
              throw new Error('ë°ì´í„°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤. ì´ë¯¸ì§€ í¬ê¸°ë‚˜ ì°¨ì´ì  ìˆ˜ë¥¼ ì¤„ì—¬ë³´ì„¸ìš”.');
            } else if (response.status === 500) {
              throw new Error('ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
            } else {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
          }
          
          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            throw new Error('ì„œë²„ì—ì„œ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ì‘ë‹µì„ ë°›ì•˜ìŠµë‹ˆë‹¤.');
          }
          
          const result = await response.json();
          
          detectionStatus.textContent = `ë°ì´í„°ë² ì´ìŠ¤ì— ì •ë‹µ ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤! (ì´ ${optimizedRegions.length}ê°œ ì˜ì—­)`;
          console.log('ì €ì¥ ì„±ê³µ:', result);
          alert(`ì €ì¥ ì™„ë£Œ!\nì´ë¯¸ì§€ ì„¸íŠ¸ ID: ${imageSetId}\ní‹€ë¦° ë¶€ë¶„: ${optimizedRegions.length}ê°œ\nì›ë³¸ ì˜ì—­: ${allRegions.length}ê°œ`);
        } catch (error) {
          console.error('ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì˜¤ë¥˜:', error);
          detectionStatus.textContent = 'ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì‹¤íŒ¨: ' + error.message;
          alert('ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
        } finally {
          // ë²„íŠ¼ ë³µì›
          saveToDatabaseBtn.disabled = false;
          saveToDatabaseBtn.textContent = 'ë°ì´í„°ë² ì´ìŠ¤ì— ì •ë‹µ ì €ì¥';
        }
      });

      // ìˆ˜ì •ëœ ì´ë¯¸ì§€ í´ë¦­ ì´ë²¤íŠ¸
      modifiedImage.addEventListener('click', function(event) {
        if (!gameMode) {
          // ì¼ë°˜ ëª¨ë“œ: ìˆ˜ë™ìœ¼ë¡œ ì  ì¶”ê°€
          const rect = this.getBoundingClientRect();
          const x = Math.round((event.clientX - rect.left) * (imageWidth / rect.width));
          const y = Math.round((event.clientY - rect.top) * (imageHeight / rect.height));
          
          addPoint(x, y);
          console.log('ì  ì¶”ê°€ë¨:', x, y);
        } else {
          // ê²Œì„ ëª¨ë“œ: ì •ë‹µ í™•ì¸
          checkAnswer(event);
        }
      });
      
      // ì  ì¶”ê°€ í•¨ìˆ˜
      function addPoint(x, y) {
        const point = { x: x, y: y };
        points.push(point);
        
        // í™”ë©´ì— ì  í‘œì‹œ
        const rect = modifiedImage.getBoundingClientRect();
        const pointElement = document.createElement('div');
        pointElement.className = 'point';
        pointElement.style.left = (x * (rect.width / imageWidth)) + 'px';
        pointElement.style.top = (y * (rect.height / imageHeight)) + 'px';
        
        modifiedContainer.appendChild(pointElement);
        
        // ë°ì´í„° ì—…ë°ì´íŠ¸
        updatePointsData();
      }
      
      // ê²Œì„ ëª¨ë“œì—ì„œ ì •ë‹µ í™•ì¸ í•¨ìˆ˜
      function checkAnswer(event) {
        const rect = modifiedImage.getBoundingClientRect();
        const clickX = Math.round((event.clientX - rect.left) * (imageWidth / rect.width));
        const clickY = Math.round((event.clientY - rect.top) * (imageHeight / rect.height));
        
        // í´ë¦­í•œ ìœ„ì¹˜ê°€ ì •ë‹µ ì˜ì—­ì— í¬í•¨ë˜ëŠ”ì§€ í™•ì¸
        for (let i = 0; i < answerRegions.length; i++) {
          if (!foundAnswers[i]) {
            const region = answerRegions[i];
            
            // ì˜ì—­ ë‚´ì˜ í”½ì…€ë“¤ê³¼ ë¹„êµ
            for (const pixel of region) {
              const distance = Math.sqrt(Math.pow(clickX - pixel.x, 2) + Math.pow(clickY - pixel.y, 2));
              
              if (distance <= 20) { // 20í”½ì…€ ë‚´ë¡œ í´ë¦­í•˜ë©´ ì •ë‹µìœ¼ë¡œ ì¸ì •
                foundAnswers[i] = true;
                showFoundAnswer(region, i);
                updateGameProgress();
                return;
              }
            }
          }
        }
        
        // ì •ë‹µì´ ì•„ë‹Œ ê³³ì„ í´ë¦­í•œ ê²½ìš°
        console.log('í‹€ë ¸ìŠµë‹ˆë‹¤!');
      }
      
      // ì°¾ì€ ì •ë‹µ í‘œì‹œ í•¨ìˆ˜
      function showFoundAnswer(region, index) {
        // ì •ë‹µ í‘œì‹œ ë°©ì‹ì— ë”°ë¼ ë‹¤ë¥´ê²Œ í‘œì‹œ
        if (answerExactRadio.checked) {
          showExactAnswer(region);
        } else if (answerOutlineRadio.checked) {
          showOutlineAnswer(region);
        } else if (answerOutlineDotsRadio.checked) {
          showOutlineAnswer(region);
        }
      }
      
      // ê²Œì„ ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
      function updateGameProgress() {
        const foundCount = foundAnswers.filter(found => found).length;
        foundCountElem.textContent = foundCount;
        
        const progress = (foundCount / answerRegions.length) * 100;
        progressFill.style.width = progress + '%';
        
        if (foundCount === answerRegions.length) {
          detectionStatus.textContent = 'ì¶•í•˜í•©ë‹ˆë‹¤! ëª¨ë“  í‹€ë¦° ë¶€ë¶„ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤!';
        } else {
          detectionStatus.textContent = `${foundCount}ê°œì˜ í‹€ë¦° ë¶€ë¶„ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤. (${answerRegions.length - foundCount}ê°œ ë‚¨ìŒ)`;
        }
      }
      
      // ì  ë°ì´í„° ì—…ë°ì´íŠ¸ í•¨ìˆ˜
      function updatePointsData() {
        const data = {
          image_width: imageWidth,
          image_height: imageHeight,
          points: points
        };
        pointsData.value = JSON.stringify(data, null, 2);
      }
      
      // ëª¨ë“  ì  ì§€ìš°ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
      clearPointsBtn.addEventListener('click', function() {
        points = [];
        const pointElements = modifiedContainer.querySelectorAll('.point');
        pointElements.forEach(element => element.remove());
        updatePointsData();
        console.log('ëª¨ë“  ì ì´ ì§€ì›Œì¡ŒìŠµë‹ˆë‹¤.');
      });
      
      // ë§ˆì§€ë§‰ ì  ì§€ìš°ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
      removeLastBtn.addEventListener('click', function() {
        if (points.length > 0) {
          points.pop();
          const pointElements = modifiedContainer.querySelectorAll('.point');
          if (pointElements.length > 0) {
            pointElements[pointElements.length - 1].remove();
          }
          updatePointsData();
          console.log('ë§ˆì§€ë§‰ ì ì´ ì§€ì›Œì¡ŒìŠµë‹ˆë‹¤.');
        }
      });
      
      // ì¢Œí‘œ ì €ì¥í•˜ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
      savePointsBtn.addEventListener('click', function() {
        if (points.length === 0) {
          alert('ì €ì¥í•  ì ì´ ì—†ìŠµë‹ˆë‹¤!');
          return;
        }
        
        const data = {
          image_width: imageWidth,
          image_height: imageHeight,
          points: points,
          timestamp: new Date().toISOString()
        };
        
        // ë¸Œë¼ìš°ì € ë‹¤ìš´ë¡œë“œ
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `difference_points_${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        console.log('ì¢Œí‘œ ë°ì´í„°ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
      });

      // ìë™ í‹€ë¦° ë¶€ë¶„ ê°ì§€ ë²„íŠ¼ ì´ë²¤íŠ¸
      detectDifferencesBtn.addEventListener('click', async function() {
        if (!originalImage.src || !modifiedImage.src) {
          alert('ë¨¼ì € ì›ë³¸ ì´ë¯¸ì§€ì™€ ìˆ˜ì •ëœ ì´ë¯¸ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”!');
          return;
        }
        
        // ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ ëŒ€ê¸°
        detectionStatus.textContent = 'ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...';
        
        try {
          // ì´ë¯¸ì§€ê°€ ì™„ì „íˆ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
          await Promise.all([
            new Promise((resolve, reject) => {
              if (originalImage.complete && originalImage.naturalWidth > 0) {
                resolve();
              } else {
                originalImage.onload = resolve;
                originalImage.onerror = reject;
                // 5ì´ˆ íƒ€ì„ì•„ì›ƒ
                setTimeout(() => reject(new Error('ì›ë³¸ ì´ë¯¸ì§€ ë¡œë“œ íƒ€ì„ì•„ì›ƒ')), 5000);
              }
            }),
            new Promise((resolve, reject) => {
              if (modifiedImage.complete && modifiedImage.naturalWidth > 0) {
                resolve();
              } else {
                modifiedImage.onload = resolve;
                modifiedImage.onerror = reject;
                // 5ì´ˆ íƒ€ì„ì•„ì›ƒ
                setTimeout(() => reject(new Error('ìˆ˜ì • ì´ë¯¸ì§€ ë¡œë“œ íƒ€ì„ì•„ì›ƒ')), 5000);
              }
            })
          ]);
          
          // ì´ë¯¸ì§€ í¬ê¸° ì—…ë°ì´íŠ¸ (í•­ìƒ naturalSize ê¸°ì¤€)
          imageWidth = Math.max(originalImage.naturalWidth, modifiedImage.naturalWidth);
          imageHeight = Math.max(originalImage.naturalHeight, modifiedImage.naturalHeight);
          
          console.log('ğŸ–¼ï¸ ì´ë¯¸ì§€ naturalSize ìˆ˜ì§‘ ì™„ë£Œ:', {
            ì›ë³¸: `${originalImage.naturalWidth}x${originalImage.naturalHeight}`,
            ìˆ˜ì •: `${modifiedImage.naturalWidth}x${modifiedImage.naturalHeight}`,
            ìµœì¢…: `${imageWidth}x${imageHeight}`
          });
          
          if (imageWidth === 0 || imageHeight === 0) {
            throw new Error('ì´ë¯¸ì§€ í¬ê¸°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          }
          
          detectionStatus.textContent = 'ì°¨ì´ì ì„ ë¶„ì„í•˜ëŠ” ì¤‘...';
          
          const result = await detectDifferences();
          
          if (result.count === 0) {
            detectionStatus.textContent = 'ì°¨ì´ì ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„ê³„ê°’ì„ ì¡°ì •í•´ë³´ì„¸ìš”.';
            return;
          }
          
          // ê²°ê³¼ ì €ì¥
          allRegions = result.regions;
          originalRegions = result.originalRegions;
          differenceMap = result.differenceMap;
          
          // ê²°ê³¼ í‘œì‹œ
          displayDifferences(result);
          
          // ê²Œì„ ì„¹ì…˜ í™œì„±í™”
          gameSection.style.display = 'block';
          
          detectionStatus.textContent = `${result.count}ê°œì˜ ì°¨ì´ì ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤ (ì´ ${result.pixelCount}ê°œ í”½ì…€).`;
          
        } catch (error) {
          console.error('ì°¨ì´ì  ê°ì§€ ì˜¤ë¥˜:', error);
          detectionStatus.textContent = 'ì°¨ì´ì  ê°ì§€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message;
        }
      });
      
      // ì„ê³„ê°’ ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸
      diffThreshold.addEventListener('input', function() {
        thresholdValue.textContent = this.value;
      });
      
      minArea.addEventListener('input', function() {
        minAreaValue.textContent = this.value;
      });
      
      mergeDistance.addEventListener('input', function() {
        mergeDistanceValue.textContent = this.value;
      });
      
      // í‘œì‹œ ëª¨ë“œ ë³€ê²½ ì´ë²¤íŠ¸
      [displayCircleRadio, displayPixelRadio, displayPreMergeRadio, displayBothRadio].forEach(radio => {
        radio.addEventListener('change', function() {
          if (allRegions.length > 0) {
            displayDifferences({
              count: allRegions.length,
              originalRegions: originalRegions,
              regions: allRegions,
              differenceMap: differenceMap
            });
          }
        });
      });
      
      // ì°¨ì´ì  í‘œì‹œ í•¨ìˆ˜
      function displayDifferences(result) {
        // ê¸°ì¡´ ìº”ë²„ìŠ¤ ì œê±°
        const existingCanvases = modifiedContainer.querySelectorAll('canvas:not(#result-canvas)');
        existingCanvases.forEach(canvas => canvas.remove());
        
        const rect = modifiedImage.getBoundingClientRect();
        const scaleX = rect.width / imageWidth;
        const scaleY = rect.height / imageHeight;
        
        if (displayCircleRadio.checked) {
          // ì›í˜• í‘œì‹œ
          showCircleRegions(result.regions, scaleX, scaleY);
        } else if (displayPixelRadio.checked) {
          // í”½ì…€ í‘œì‹œ
          showPixelRegions(result.regions, scaleX, scaleY);
        } else if (displayPreMergeRadio.checked) {
          // ë³‘í•© ì „ ì˜ì—­
          showPixelRegions(result.originalRegions, scaleX, scaleY, 'rgba(255, 165, 0, 0.7)');
        } else if (displayBothRadio.checked) {
          // ë³‘í•© ì „/í›„ ë¹„êµ
          showPixelRegions(result.originalRegions, scaleX, scaleY, 'rgba(255, 165, 0, 0.7)');
          showPixelRegions(result.regions, scaleX, scaleY, 'rgba(255, 0, 0, 0.7)');
          colorLegend.style.display = 'flex';
        }
        
        if (!displayBothRadio.checked) {
          colorLegend.style.display = 'none';
        }
      }
      
      // ì›í˜•ìœ¼ë¡œ ì˜ì—­ í‘œì‹œ
      function showCircleRegions(regions, scaleX, scaleY) {
        regions.forEach(region => {
          let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
          
          for (const pixel of region) {
            minX = Math.min(minX, pixel.x);
            minY = Math.min(minY, pixel.y);
            maxX = Math.max(maxX, pixel.x);
            maxY = Math.max(maxY, pixel.y);
          }
          
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          const radius = Math.max(maxX - minX, maxY - minY) / 2 + 10;
          
          const circle = document.createElement('div');
          circle.className = 'point';
          circle.style.left = (centerX * scaleX) + 'px';
          circle.style.top = (centerY * scaleY) + 'px';
          circle.style.width = (radius * 2 * scaleX) + 'px';
          circle.style.height = (radius * 2 * scaleY) + 'px';
          
          modifiedContainer.appendChild(circle);
        });
      }
      
      // í”½ì…€ë¡œ ì˜ì—­ í‘œì‹œ
      function showPixelRegions(regions, scaleX, scaleY, color = 'rgba(255, 0, 0, 0.7)') {
        const canvas = document.createElement('canvas');
        canvas.width = modifiedImage.getBoundingClientRect().width;
        canvas.height = modifiedImage.getBoundingClientRect().height;
        canvas.style.position = 'absolute';
        canvas.style.left = '0';
        canvas.style.top = '0';
        canvas.style.pointerEvents = 'none';
        canvas.style.zIndex = '5';
        
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color;
        
        regions.forEach(region => {
          region.forEach(pixel => {
            const x = pixel.x * scaleX;
            const y = pixel.y * scaleY;
            const size = Math.max(1, Math.min(scaleX, scaleY));
            ctx.fillRect(x - size/2, y - size/2, size, size);
          });
        });
        
        modifiedContainer.appendChild(canvas);
      }
    });
  </script>
</body>
</html> 